{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, KeyCodes, css, elementContains, format, getId, classNamesFunction, styled, initializeComponentRef } from '../../Utilities';\nimport { Callout } from '../../Callout';\nimport { Selection, SelectionZone, SelectionMode } from '../../utilities/selection/index';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { Suggestions } from './Suggestions/Suggestions';\nimport { getStyles as suggestionsStyles } from './Suggestions/Suggestions.styles';\nimport { SuggestionsController } from './Suggestions/SuggestionsController';\nimport { ValidationState } from './BasePicker.types';\nimport { Autofill } from '../Autofill/index';\nimport * as stylesImport from './BasePicker.scss';\nvar legacyStyles = stylesImport;\nvar getClassNames = classNamesFunction();\n/**\n * Should be removed once new picker without inheritance is created\n */\n\nfunction getStyledSuggestions(suggestionsType) {\n  return styled(suggestionsType, suggestionsStyles, undefined, {\n    scope: 'Suggestions'\n  });\n}\n/**\n * {@docCategory Pickers}\n */\n\n\nvar BasePicker =\n/** @class */\nfunction (_super) {\n  __extends(BasePicker, _super);\n\n  function BasePicker(basePickerProps) {\n    var _this = _super.call(this, basePickerProps) || this; // Refs\n\n\n    _this.root = React.createRef();\n    _this.input = React.createRef();\n    _this.suggestionElement = React.createRef();\n    /**\n     * @deprecated this is no longer necessary as typescript now supports generic elements\n     */\n\n    _this.SuggestionOfProperType = Suggestions; // eslint-disable-next-line deprecation/deprecation\n\n    _this._styledSuggestions = getStyledSuggestions(_this.SuggestionOfProperType);\n\n    _this.dismissSuggestions = function (ev) {\n      var selectItemFunction = function selectItemFunction() {\n        var addItemOnDismiss = true;\n\n        if (_this.props.onDismiss) {\n          addItemOnDismiss = _this.props.onDismiss(ev, _this.suggestionStore.currentSuggestion ? _this.suggestionStore.currentSuggestion.item : undefined);\n        }\n\n        if (!ev || ev && !ev.defaultPrevented) {\n          // Select the first suggestion if one is available and permitted by onDismiss when user leaves.\n          if (addItemOnDismiss !== false && _this.canAddItems() && _this.suggestionStore.hasSelectedSuggestion() && _this.state.suggestedDisplayValue) {\n            _this.addItemByIndex(0);\n          }\n        }\n      };\n\n      if (_this.currentPromise) {\n        _this.currentPromise.then(function () {\n          return selectItemFunction();\n        });\n      } else {\n        selectItemFunction();\n      }\n\n      _this.setState({\n        suggestionsVisible: false\n      });\n    };\n\n    _this.refocusSuggestions = function (keyCode) {\n      _this.resetFocus();\n\n      if (_this.suggestionStore.suggestions && _this.suggestionStore.suggestions.length > 0) {\n        if (keyCode === KeyCodes.up) {\n          _this.suggestionStore.setSelectedSuggestion(_this.suggestionStore.suggestions.length - 1);\n        } else if (keyCode === KeyCodes.down) {\n          _this.suggestionStore.setSelectedSuggestion(0);\n        }\n      }\n    };\n\n    _this.onInputChange = function (value) {\n      _this.updateValue(value);\n\n      _this.setState({\n        moreSuggestionsAvailable: true,\n        isMostRecentlyUsedVisible: false\n      });\n    };\n\n    _this.onSuggestionClick = function (ev, item, index) {\n      _this.addItemByIndex(index);\n    };\n\n    _this.onSuggestionRemove = function (ev, item, index) {\n      if (_this.props.onRemoveSuggestion) {\n        _this.props.onRemoveSuggestion(item);\n      }\n\n      _this.suggestionStore.removeSuggestion(index);\n    };\n\n    _this.onInputFocus = function (ev) {\n      _this.selection.setAllSelected(false); // Only trigger all of the focus if this component isn't already focused.\n      // For example when an item is selected or removed from the selected list it should be treated\n      // as though the input is still focused.\n\n\n      if (!_this.state.isFocused) {\n        _this._userTriggeredSuggestions();\n\n        if (_this.props.inputProps && _this.props.inputProps.onFocus) {\n          _this.props.inputProps.onFocus(ev);\n        }\n      }\n    };\n\n    _this.onInputBlur = function (ev) {\n      if (_this.props.inputProps && _this.props.inputProps.onBlur) {\n        _this.props.inputProps.onBlur(ev);\n      }\n    };\n\n    _this.onBlur = function (ev) {\n      if (_this.state.isFocused) {\n        // Only blur the entire component if an unrelated element gets focus.\n        // Otherwise treat it as though it still has focus.\n        // Do nothing if the blur is coming from something\n        // inside the comboBox root or the comboBox menu since\n        // it we are not really bluring from the whole comboBox\n        var relatedTarget = ev.relatedTarget;\n\n        if (ev.relatedTarget === null) {\n          // In IE11, due to lack of support, event.relatedTarget is always\n          // null making every onBlur call to be \"outside\" of the ComboBox\n          // even when it's not. Using document.activeElement is another way\n          // for us to be able to get what the relatedTarget without relying\n          // on the event\n          relatedTarget = document.activeElement;\n        }\n\n        if (relatedTarget && !elementContains(_this.root.current, relatedTarget)) {\n          _this.setState({\n            isFocused: false\n          });\n\n          if (_this.props.onBlur) {\n            _this.props.onBlur(ev);\n          }\n        }\n      }\n    };\n    /**\n     * Resets focus to last element in wrapper div if clicking back into Picker that has hit item limit\n     */\n\n\n    _this.onWrapperClick = function (ev) {\n      if (!_this.canAddItems()) {\n        _this.resetFocus(_this.state.items.length - 1);\n      }\n    };\n    /**\n     * Reveals suggestions any time the user clicks on the input element\n     * without shifting focus.\n     */\n\n\n    _this.onClick = function (ev) {\n      if (_this.props.inputProps !== undefined && _this.props.inputProps.onClick !== undefined) {\n        _this.props.inputProps.onClick(ev);\n      } // Only primary (left) clicks show suggestions.\n\n\n      if (ev.button === 0) {\n        _this._userTriggeredSuggestions();\n      }\n    };\n\n    _this.onFocus = function () {\n      if (!_this.state.isFocused) {\n        _this.setState({\n          isFocused: true\n        });\n      }\n    };\n\n    _this.onKeyDown = function (ev) {\n      // eslint-disable-next-line deprecation/deprecation\n      var keyCode = ev.which;\n\n      switch (keyCode) {\n        case KeyCodes.escape:\n          if (_this.state.suggestionsVisible) {\n            _this.setState({\n              suggestionsVisible: false\n            });\n\n            ev.preventDefault();\n            ev.stopPropagation();\n          }\n\n          break;\n\n        case KeyCodes.tab:\n        case KeyCodes.enter:\n          if (_this.suggestionElement.current && _this.suggestionElement.current.hasSuggestedActionSelected()) {\n            _this.suggestionElement.current.executeSelectedAction();\n          } else if (!ev.shiftKey && _this.suggestionStore.hasSelectedSuggestion() && _this.state.suggestionsVisible) {\n            _this.completeSuggestion();\n\n            ev.preventDefault();\n            ev.stopPropagation();\n          } else {\n            _this._completeGenericSuggestion();\n          }\n\n          break;\n\n        case KeyCodes.backspace:\n          if (!_this.props.disabled) {\n            _this.onBackspace(ev);\n          }\n\n          ev.stopPropagation();\n          break;\n\n        case KeyCodes.del:\n          if (!_this.props.disabled) {\n            if (_this.input.current && ev.target === _this.input.current.inputElement && _this.state.suggestionsVisible && _this.suggestionStore.currentIndex !== -1) {\n              if (_this.props.onRemoveSuggestion) {\n                _this.props.onRemoveSuggestion(_this.suggestionStore.currentSuggestion.item);\n              }\n\n              _this.suggestionStore.removeSuggestion(_this.suggestionStore.currentIndex);\n\n              _this.forceUpdate();\n            } else {\n              _this.onBackspace(ev);\n            }\n          }\n\n          ev.stopPropagation();\n          break;\n\n        case KeyCodes.up:\n          if (_this.input.current && ev.target === _this.input.current.inputElement && _this.state.suggestionsVisible) {\n            if (_this.suggestionElement.current && _this.suggestionElement.current.tryHandleKeyDown(keyCode, _this.suggestionStore.currentIndex)) {\n              ev.preventDefault();\n              ev.stopPropagation();\n\n              _this.forceUpdate();\n            } else {\n              if (_this.suggestionElement.current && _this.suggestionElement.current.hasSuggestedAction() && _this.suggestionStore.currentIndex === 0) {\n                ev.preventDefault();\n                ev.stopPropagation();\n\n                _this.suggestionElement.current.focusAboveSuggestions();\n\n                _this.suggestionStore.deselectAllSuggestions();\n\n                _this.forceUpdate();\n              } else {\n                if (_this.suggestionStore.previousSuggestion()) {\n                  ev.preventDefault();\n                  ev.stopPropagation();\n\n                  _this.onSuggestionSelect();\n                }\n              }\n            }\n          }\n\n          break;\n\n        case KeyCodes.down:\n          if (_this.input.current && ev.target === _this.input.current.inputElement && _this.state.suggestionsVisible) {\n            if (_this.suggestionElement.current && _this.suggestionElement.current.tryHandleKeyDown(keyCode, _this.suggestionStore.currentIndex)) {\n              ev.preventDefault();\n              ev.stopPropagation();\n\n              _this.forceUpdate();\n            } else {\n              if (_this.suggestionElement.current && _this.suggestionElement.current.hasSuggestedAction() && _this.suggestionStore.currentIndex + 1 === _this.suggestionStore.suggestions.length) {\n                ev.preventDefault();\n                ev.stopPropagation();\n\n                _this.suggestionElement.current.focusBelowSuggestions();\n\n                _this.suggestionStore.deselectAllSuggestions();\n\n                _this.forceUpdate();\n              } else {\n                if (_this.suggestionStore.nextSuggestion()) {\n                  ev.preventDefault();\n                  ev.stopPropagation();\n\n                  _this.onSuggestionSelect();\n                }\n              }\n            }\n          }\n\n          break;\n      }\n    };\n\n    _this.onItemChange = function (changedItem, index) {\n      var items = _this.state.items;\n\n      if (index >= 0) {\n        var newItems = items;\n        newItems[index] = changedItem;\n\n        _this._updateSelectedItems(newItems);\n      }\n    };\n\n    _this.onGetMoreResults = function () {\n      _this.setState({\n        isSearching: true\n      }, function () {\n        if (_this.props.onGetMoreResults && _this.input.current) {\n          var suggestions = _this.props.onGetMoreResults(_this.input.current.value, _this.state.items);\n\n          var suggestionsArray = suggestions;\n          var suggestionsPromiseLike = suggestions;\n\n          if (Array.isArray(suggestionsArray)) {\n            _this.updateSuggestions(suggestionsArray);\n\n            _this.setState({\n              isSearching: false\n            });\n          } else if (suggestionsPromiseLike.then) {\n            suggestionsPromiseLike.then(function (newSuggestions) {\n              _this.updateSuggestions(newSuggestions);\n\n              _this.setState({\n                isSearching: false\n              });\n            });\n          }\n        } else {\n          _this.setState({\n            isSearching: false\n          });\n        }\n\n        if (_this.input.current) {\n          _this.input.current.focus();\n        }\n\n        _this.setState({\n          moreSuggestionsAvailable: false,\n          isResultsFooterVisible: true\n        });\n      });\n    };\n\n    _this.completeSelection = function (item) {\n      _this.addItem(item);\n\n      _this.updateValue('');\n\n      if (_this.input.current) {\n        _this.input.current.clear();\n      }\n\n      _this.setState({\n        suggestionsVisible: false\n      });\n    };\n\n    _this.addItemByIndex = function (index) {\n      _this.completeSelection(_this.suggestionStore.getSuggestionAtIndex(index).item);\n    };\n\n    _this.addItem = function (item) {\n      var processedItem = _this.props.onItemSelected ? _this.props.onItemSelected(item) : item;\n\n      if (processedItem === null) {\n        return;\n      }\n\n      var processedItemObject = processedItem;\n      var processedItemPromiseLike = processedItem;\n\n      if (processedItemPromiseLike && processedItemPromiseLike.then) {\n        processedItemPromiseLike.then(function (resolvedProcessedItem) {\n          var newItems = _this.state.items.concat([resolvedProcessedItem]);\n\n          _this._updateSelectedItems(newItems);\n        });\n      } else {\n        var newItems = _this.state.items.concat([processedItemObject]);\n\n        _this._updateSelectedItems(newItems);\n      }\n\n      _this.setState({\n        suggestedDisplayValue: '',\n        selectionRemoved: undefined\n      });\n    };\n\n    _this.removeItem = function (item) {\n      var items = _this.state.items;\n      var index = items.indexOf(item);\n\n      if (index >= 0) {\n        var newItems = items.slice(0, index).concat(items.slice(index + 1));\n\n        _this.setState({\n          selectionRemoved: item\n        });\n\n        _this._updateSelectedItems(newItems);\n      }\n    };\n\n    _this.removeItems = function (itemsToRemove) {\n      var items = _this.state.items;\n      var newItems = items.filter(function (item) {\n        return itemsToRemove.indexOf(item) === -1;\n      });\n\n      _this._updateSelectedItems(newItems);\n    };\n    /**\n     * @deprecated this is no longer necessary as focuszone has been removed\n     */\n\n\n    _this._shouldFocusZoneEnterInnerZone = function (ev) {\n      // If suggestions are shown const up/down keys control them, otherwise allow them through to control the focusZone.\n      if (_this.state.suggestionsVisible) {\n        // eslint-disable-next-line deprecation/deprecation\n        switch (ev.which) {\n          case KeyCodes.up:\n          case KeyCodes.down:\n            return true;\n        }\n      } // eslint-disable-next-line deprecation/deprecation\n\n\n      if (ev.which === KeyCodes.enter) {\n        return true;\n      }\n\n      return false;\n    };\n\n    _this._onResolveSuggestions = function (updatedValue) {\n      var suggestions = _this.props.onResolveSuggestions(updatedValue, _this.state.items);\n\n      if (suggestions !== null) {\n        _this.updateSuggestionsList(suggestions, updatedValue);\n      }\n    };\n\n    _this._completeGenericSuggestion = function () {\n      if (_this.props.onValidateInput && _this.input.current && _this.props.onValidateInput(_this.input.current.value) !== ValidationState.invalid && _this.props.createGenericItem) {\n        var itemToConvert = _this.props.createGenericItem(_this.input.current.value, _this.props.onValidateInput(_this.input.current.value));\n\n        _this.suggestionStore.createGenericSuggestion(itemToConvert);\n\n        _this.completeSuggestion();\n      }\n    };\n    /**\n     * This should be called when the user does something other than use text entry to trigger suggestions.\n     *\n     */\n\n\n    _this._userTriggeredSuggestions = function () {\n      if (!_this.state.suggestionsVisible) {\n        var input = _this.input.current ? _this.input.current.value : '';\n\n        if (!input) {\n          _this.onEmptyInputFocus();\n        } else {\n          if (_this.suggestionStore.suggestions.length === 0) {\n            _this._onResolveSuggestions(input);\n          } else {\n            _this.setState({\n              isMostRecentlyUsedVisible: false,\n              suggestionsVisible: true\n            });\n          }\n        }\n      }\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    var items = basePickerProps.selectedItems || basePickerProps.defaultSelectedItems || [];\n    _this._id = getId();\n    _this._ariaMap = {\n      selectedItems: \"selected-items-\" + _this._id,\n      selectedSuggestionAlert: \"selected-suggestion-alert-\" + _this._id,\n      suggestionList: \"suggestion-list-\" + _this._id,\n      combobox: \"combobox-\" + _this._id\n    };\n    _this.suggestionStore = new SuggestionsController();\n    _this.selection = new Selection({\n      onSelectionChanged: function onSelectionChanged() {\n        return _this.onSelectionChange();\n      }\n    });\n\n    _this.selection.setItems(items);\n\n    _this.state = {\n      items: items,\n      suggestedDisplayValue: '',\n      isMostRecentlyUsedVisible: false,\n      moreSuggestionsAvailable: false,\n      isFocused: false,\n      isSearching: false,\n      selectedIndices: [],\n      selectionRemoved: undefined\n    };\n    return _this;\n  }\n\n  BasePicker.getDerivedStateFromProps = function (newProps) {\n    if (newProps.selectedItems) {\n      return {\n        items: newProps.selectedItems\n      };\n    }\n\n    return null;\n  };\n\n  Object.defineProperty(BasePicker.prototype, \"items\", {\n    get: function get() {\n      return this.state.items;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  BasePicker.prototype.componentDidMount = function () {\n    this.selection.setItems(this.state.items);\n    this._onResolveSuggestions = this._async.debounce(this._onResolveSuggestions, this.props.resolveDelay);\n  };\n\n  BasePicker.prototype.componentDidUpdate = function (oldProps, oldState) {\n    if (this.state.items && this.state.items !== oldState.items) {\n      var currentSelectedIndex = this.selection.getSelectedIndices()[0];\n      this.selection.setItems(this.state.items);\n\n      if (this.state.isFocused) {\n        // Reset focus and selection so that selected item stays in sync if something\n        // has been removed\n        if (this.state.items.length < oldState.items.length) {\n          this.selection.setIndexSelected(currentSelectedIndex, false, true);\n          this.resetFocus(currentSelectedIndex);\n        } // Reset focus to last item if the input is removed\n        else if (this.state.items.length > oldState.items.length && !this.canAddItems()) {\n          this.resetFocus(this.state.items.length - 1);\n        }\n      }\n    }\n  };\n\n  BasePicker.prototype.componentWillUnmount = function () {\n    if (this.currentPromise) {\n      this.currentPromise = undefined;\n    }\n\n    this._async.dispose();\n  };\n\n  BasePicker.prototype.focus = function () {\n    if (this.input.current) {\n      this.input.current.focus();\n    }\n  };\n\n  BasePicker.prototype.focusInput = function () {\n    if (this.input.current) {\n      this.input.current.focus();\n    }\n  };\n\n  BasePicker.prototype.completeSuggestion = function (forceComplete) {\n    if (this.suggestionStore.hasSelectedSuggestion() && this.input.current) {\n      this.completeSelection(this.suggestionStore.currentSuggestion.item);\n    } else if (forceComplete) {\n      this._completeGenericSuggestion();\n    }\n  };\n\n  BasePicker.prototype.render = function () {\n    var _a = this.state,\n        suggestedDisplayValue = _a.suggestedDisplayValue,\n        isFocused = _a.isFocused,\n        items = _a.items;\n    var _b = this.props,\n        className = _b.className,\n        inputProps = _b.inputProps,\n        disabled = _b.disabled,\n        selectionAriaLabel = _b.selectionAriaLabel,\n        _c = _b.selectionRole,\n        selectionRole = _c === void 0 ? 'list' : _c,\n        theme = _b.theme,\n        styles = _b.styles;\n    var suggestionsVisible = !!this.state.suggestionsVisible;\n    var suggestionsAvailable = suggestionsVisible ? this._ariaMap.suggestionList : undefined; // TODO\n    // Clean this up by leaving only the first part after removing support for SASS.\n    // Currently we can not remove the SASS styles from BasePicker class because it\n    // might be used by consumers who created custom pickers from extending from\n    // this base class and have not used the new 'styles' prop.\n    // We check for 'styles' prop which is going to be injected by the 'styled' HOC\n    // for every other already existing picker variant (PeoplePicker, TagPicker)\n    // so that we can use the CSS-in-JS styles. If the check fails (ex: custom picker),\n    // then we just use the old SASS styles instead.\n\n    var classNames = styles ? getClassNames(styles, {\n      theme: theme,\n      className: className,\n      isFocused: isFocused,\n      disabled: disabled,\n      inputClassName: inputProps && inputProps.className\n    }) : {\n      root: css('ms-BasePicker', className ? className : ''),\n      text: css('ms-BasePicker-text', legacyStyles.pickerText, this.state.isFocused && legacyStyles.inputFocused),\n      itemsWrapper: legacyStyles.pickerItems,\n      input: css('ms-BasePicker-input', legacyStyles.pickerInput, inputProps && inputProps.className),\n      screenReaderText: legacyStyles.screenReaderOnly\n    };\n    var comboLabel = this.props['aria-label'] || (inputProps === null || inputProps === void 0 ? void 0 : inputProps['aria-label']); // selectionAriaLabel is contained in a separate <span> rather than an aria-label on the items list\n    // because if the items list has an aria-label, the aria-describedby on the input will only read\n    // that label instead of all the selected items. Using aria-labelledby instead fixes this, since\n    // aria-describedby and aria-labelledby will not follow a second aria-labelledby\n\n    return React.createElement(\"div\", {\n      ref: this.root,\n      className: classNames.root,\n      onKeyDown: this.onKeyDown,\n      onFocus: this.onFocus,\n      onBlur: this.onBlur,\n      onClick: this.onWrapperClick\n    }, this.renderCustomAlert(classNames.screenReaderText), React.createElement(\"span\", {\n      id: this._ariaMap.selectedItems + \"-label\",\n      hidden: true\n    }, selectionAriaLabel || comboLabel), React.createElement(SelectionZone, {\n      selection: this.selection,\n      selectionMode: SelectionMode.multiple\n    }, React.createElement(\"div\", {\n      className: classNames.text,\n      \"aria-owns\": suggestionsAvailable\n    }, items.length > 0 && React.createElement(\"span\", {\n      id: this._ariaMap.selectedItems,\n      className: classNames.itemsWrapper,\n      role: selectionRole,\n      \"aria-labelledby\": this._ariaMap.selectedItems + \"-label\"\n    }, this.renderItems()), this.canAddItems() && React.createElement(Autofill, __assign({\n      spellCheck: false\n    }, inputProps, {\n      className: classNames.input,\n      componentRef: this.input,\n      id: (inputProps === null || inputProps === void 0 ? void 0 : inputProps.id) ? inputProps.id : this._ariaMap.combobox,\n      onClick: this.onClick,\n      onFocus: this.onInputFocus,\n      onBlur: this.onInputBlur,\n      onInputValueChange: this.onInputChange,\n      suggestedDisplayValue: suggestedDisplayValue,\n      \"aria-activedescendant\": suggestionsVisible ? this.getActiveDescendant() : undefined,\n      \"aria-controls\": suggestionsAvailable,\n      \"aria-describedby\": items.length > 0 ? this._ariaMap.selectedItems : undefined,\n      \"aria-expanded\": suggestionsVisible,\n      \"aria-haspopup\": \"listbox\",\n      \"aria-label\": comboLabel,\n      role: \"combobox\",\n      disabled: disabled,\n      onInputChange: this.props.onInputChange\n    })))), this.renderSuggestions());\n  };\n\n  BasePicker.prototype.canAddItems = function () {\n    var items = this.state.items;\n    var itemLimit = this.props.itemLimit;\n    return itemLimit === undefined || items.length < itemLimit;\n  };\n\n  BasePicker.prototype.renderSuggestions = function () {\n    var StyledTypedSuggestions = this._styledSuggestions;\n    return this.state.suggestionsVisible && this.input ? React.createElement(Callout, __assign({\n      isBeakVisible: false,\n      gapSpace: 5,\n      target: this.input.current ? this.input.current.inputElement : undefined,\n      onDismiss: this.dismissSuggestions,\n      directionalHint: DirectionalHint.bottomLeftEdge,\n      directionalHintForRTL: DirectionalHint.bottomRightEdge\n    }, this.props.pickerCalloutProps), React.createElement(StyledTypedSuggestions // Assumed to set in derived component's defaultProps\n    , __assign({\n      // Assumed to set in derived component's defaultProps\n      onRenderSuggestion: this.props.onRenderSuggestionsItem,\n      onSuggestionClick: this.onSuggestionClick,\n      onSuggestionRemove: this.onSuggestionRemove,\n      suggestions: this.suggestionStore.getSuggestions(),\n      componentRef: this.suggestionElement,\n      onGetMoreResults: this.onGetMoreResults,\n      moreSuggestionsAvailable: this.state.moreSuggestionsAvailable,\n      isLoading: this.state.suggestionsLoading,\n      isSearching: this.state.isSearching,\n      isMostRecentlyUsedVisible: this.state.isMostRecentlyUsedVisible,\n      isResultsFooterVisible: this.state.isResultsFooterVisible,\n      refocusSuggestions: this.refocusSuggestions,\n      removeSuggestionAriaLabel: this.props.removeButtonAriaLabel,\n      suggestionsListId: this._ariaMap.suggestionList,\n      createGenericItem: this._completeGenericSuggestion\n    }, this.props.pickerSuggestionsProps))) : null;\n  };\n\n  BasePicker.prototype.renderItems = function () {\n    var _this = this;\n\n    var _a = this.props,\n        disabled = _a.disabled,\n        removeButtonAriaLabel = _a.removeButtonAriaLabel,\n        removeButtonIconProps = _a.removeButtonIconProps;\n    var onRenderItem = this.props.onRenderItem;\n    var _b = this.state,\n        items = _b.items,\n        selectedIndices = _b.selectedIndices;\n    return items.map(function (item, index) {\n      return onRenderItem({\n        item: item,\n        index: index,\n        key: item.key ? item.key : index,\n        selected: selectedIndices.indexOf(index) !== -1,\n        onRemoveItem: function onRemoveItem() {\n          return _this.removeItem(item);\n        },\n        disabled: disabled,\n        onItemChange: _this.onItemChange,\n        removeButtonAriaLabel: removeButtonAriaLabel,\n        removeButtonIconProps: removeButtonIconProps\n      });\n    });\n  };\n\n  BasePicker.prototype.resetFocus = function (index) {\n    var items = this.state.items;\n\n    if (items.length && index >= 0) {\n      var newEl = this.root.current && this.root.current.querySelectorAll('[data-selection-index]')[Math.min(index, items.length - 1)];\n\n      if (newEl) {\n        newEl.focus();\n      }\n    } else if (!this.canAddItems()) {\n      this.resetFocus(items.length - 1);\n    } else {\n      if (this.input.current) {\n        this.input.current.focus();\n      }\n    }\n  };\n\n  BasePicker.prototype.onSuggestionSelect = function () {\n    if (this.suggestionStore.currentSuggestion) {\n      var currentValue = this.input.current ? this.input.current.value : '';\n\n      var itemValue = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, currentValue);\n\n      this.setState({\n        suggestedDisplayValue: itemValue\n      });\n    }\n  };\n\n  BasePicker.prototype.onSelectionChange = function () {\n    this.setState({\n      selectedIndices: this.selection.getSelectedIndices()\n    });\n  };\n\n  BasePicker.prototype.updateSuggestions = function (suggestions) {\n    this.suggestionStore.updateSuggestions(suggestions, 0);\n    this.forceUpdate();\n  };\n  /**\n   * Only to be called when there is nothing in the input. Checks to see if the consumer has\n   * provided a function to resolve suggestions\n   */\n\n\n  BasePicker.prototype.onEmptyInputFocus = function () {\n    var emptyResolveSuggestions = this.props.onEmptyResolveSuggestions ? this.props.onEmptyResolveSuggestions : // eslint-disable-next-line deprecation/deprecation\n    this.props.onEmptyInputFocus; // Only attempt to resolve suggestions if it exists\n\n    if (emptyResolveSuggestions) {\n      var suggestions = emptyResolveSuggestions(this.state.items);\n      this.updateSuggestionsList(suggestions);\n      this.setState({\n        isMostRecentlyUsedVisible: true,\n        suggestionsVisible: true,\n        moreSuggestionsAvailable: false\n      });\n    }\n  };\n\n  BasePicker.prototype.updateValue = function (updatedValue) {\n    this._onResolveSuggestions(updatedValue);\n  };\n\n  BasePicker.prototype.updateSuggestionsList = function (suggestions, updatedValue) {\n    var _this = this; // Check to see if the returned value is an array, if it is then just pass it into the next function .\n    // If the returned value is not an array then check to see if it's a promise or PromiseLike.\n    // If it is then resolve it asynchronously.\n\n\n    if (Array.isArray(suggestions)) {\n      this._updateAndResolveValue(updatedValue, suggestions);\n    } else if (suggestions && suggestions.then) {\n      this.setState({\n        suggestionsLoading: true\n      }); // Clear suggestions\n\n      this.suggestionStore.updateSuggestions([]);\n\n      if (updatedValue !== undefined) {\n        this.setState({\n          suggestionsVisible: this._getShowSuggestions()\n        });\n      } else {\n        this.setState({\n          suggestionsVisible: this.input.current && this.input.current.inputElement === document.activeElement\n        });\n      } // Ensure that the promise will only use the callback if it was the most recent one.\n\n\n      this.currentPromise = suggestions;\n      suggestions.then(function (newSuggestions) {\n        if (suggestions === _this.currentPromise) {\n          _this._updateAndResolveValue(updatedValue, newSuggestions);\n        }\n      });\n    }\n  };\n\n  BasePicker.prototype.resolveNewValue = function (updatedValue, suggestions) {\n    var _this = this;\n\n    this.updateSuggestions(suggestions);\n    var itemValue = undefined;\n\n    if (this.suggestionStore.currentSuggestion) {\n      itemValue = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, updatedValue);\n    } // Only set suggestionloading to false after there has been time for the new suggestions to flow\n    // to the suggestions list. This is to ensure that the suggestions are available before aria-activedescendant\n    // is set so that screen readers will read out the first selected option.\n\n\n    this.setState({\n      suggestedDisplayValue: itemValue,\n      suggestionsVisible: this._getShowSuggestions()\n    }, function () {\n      return _this.setState({\n        suggestionsLoading: false\n      });\n    });\n  };\n\n  BasePicker.prototype.onChange = function (items) {\n    if (this.props.onChange) {\n      this.props.onChange(items);\n    }\n  }; // This is protected because we may expect the backspace key to work differently in a different kind of picker.\n  // This lets the subclass override it and provide it's own onBackspace. For an example see the BasePickerListBelow\n\n\n  BasePicker.prototype.onBackspace = function (ev) {\n    if (this.state.items.length && !this.input.current || this.input.current && !this.input.current.isValueSelected && this.input.current.cursorLocation === 0) {\n      if (this.selection.getSelectedCount() > 0) {\n        this.removeItems(this.selection.getSelection());\n      } else {\n        this.removeItem(this.state.items[this.state.items.length - 1]);\n      }\n    }\n  };\n\n  BasePicker.prototype.getActiveDescendant = function () {\n    var _a;\n\n    if (this.state.suggestionsLoading) {\n      return undefined;\n    }\n\n    var currentIndex = this.suggestionStore.currentIndex;\n\n    if (currentIndex < 0) {\n      // if the suggestions element has actions and the currentIndex does not point to a suggestion,\n      // return the action id\n      if ((_a = this.suggestionElement.current) === null || _a === void 0 ? void 0 : _a.hasSuggestedAction()) {\n        return 'sug-selectedAction';\n      } // If there are no suggestions and no action suggested, then return the ID for the no results found.\n\n\n      if (this.suggestionStore.suggestions.length === 0) {\n        return 'sug-noResultsFound';\n      }\n\n      return undefined;\n    } else {\n      return \"sug-\" + currentIndex;\n    }\n  };\n  /** @deprecated use renderCustomAlert instead */\n\n\n  BasePicker.prototype.getSuggestionsAlert = function (suggestionAlertClassName) {\n    if (suggestionAlertClassName === void 0) {\n      suggestionAlertClassName = legacyStyles.screenReaderOnly;\n    }\n\n    var currentIndex = this.suggestionStore.currentIndex;\n\n    if (this.props.enableSelectedSuggestionAlert) {\n      var selectedSuggestion = currentIndex > -1 ? this.suggestionStore.getSuggestionAtIndex(this.suggestionStore.currentIndex) : undefined;\n      var selectedSuggestionAlertText = selectedSuggestion ? selectedSuggestion.ariaLabel : undefined; // keeping the id/className here for legacy support\n\n      return React.createElement(\"div\", {\n        id: this._ariaMap.selectedSuggestionAlert,\n        className: suggestionAlertClassName\n      }, selectedSuggestionAlertText + \" \");\n    }\n  };\n\n  BasePicker.prototype.renderCustomAlert = function (alertClassName) {\n    if (alertClassName === void 0) {\n      alertClassName = legacyStyles.screenReaderOnly;\n    }\n\n    var _a = this.props.suggestionRemovedText,\n        suggestionRemovedText = _a === void 0 ? 'removed {0}' : _a;\n    var removedItemText = '';\n\n    if (this.state.selectionRemoved) {\n      var itemName = this._getTextFromItem(this.state.selectionRemoved, '');\n\n      removedItemText = format(suggestionRemovedText, itemName);\n    }\n\n    return React.createElement(\"div\", {\n      className: alertClassName,\n      id: this._ariaMap.selectedSuggestionAlert,\n      \"aria-live\": \"assertive\"\n    }, // eslint-disable-next-line deprecation/deprecation\n    this.getSuggestionsAlert(alertClassName), removedItemText);\n  };\n  /**\n   * Takes in the current updated value and either resolves it with the new suggestions\n   * or if updated value is undefined then it clears out currently suggested items\n   */\n\n\n  BasePicker.prototype._updateAndResolveValue = function (updatedValue, newSuggestions) {\n    if (updatedValue !== undefined) {\n      this.resolveNewValue(updatedValue, newSuggestions);\n    } else {\n      this.suggestionStore.updateSuggestions(newSuggestions, -1);\n\n      if (this.state.suggestionsLoading) {\n        this.setState({\n          suggestionsLoading: false\n        });\n      }\n    }\n  };\n  /**\n   * Controls what happens whenever there is an action that impacts the selected items.\n   * If `selectedItems` is provided, this will act as a controlled component and it will not update its own state.\n   */\n\n\n  BasePicker.prototype._updateSelectedItems = function (items) {\n    var _this = this;\n\n    if (this.props.selectedItems) {\n      // If the component is a controlled component then the controlling component will need to add or remove the items.\n      this.onChange(items);\n    } else {\n      this.setState({\n        items: items\n      }, function () {\n        _this._onSelectedItemsUpdated(items);\n      });\n    }\n  };\n\n  BasePicker.prototype._onSelectedItemsUpdated = function (items) {\n    this.onChange(items);\n  };\n  /**\n   * Suggestions are normally shown after the user updates text and the text\n   * is non-empty, but also when the user clicks on the input element.\n   * @returns True if suggestions should be shown.\n   */\n\n\n  BasePicker.prototype._getShowSuggestions = function () {\n    var areSuggestionsVisible = this.input.current !== undefined && this.input.current !== null && this.input.current.inputElement === document.activeElement && this.input.current.value !== '';\n    return areSuggestionsVisible;\n  };\n\n  BasePicker.prototype._getTextFromItem = function (item, currentValue) {\n    if (this.props.getTextFromItem) {\n      return this.props.getTextFromItem(item, currentValue);\n    } else {\n      return '';\n    }\n  };\n\n  return BasePicker;\n}(React.Component);\n\nexport { BasePicker };\n\nvar BasePickerListBelow =\n/** @class */\nfunction (_super) {\n  __extends(BasePickerListBelow, _super);\n\n  function BasePickerListBelow() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  BasePickerListBelow.prototype.render = function () {\n    var _a = this.state,\n        suggestedDisplayValue = _a.suggestedDisplayValue,\n        isFocused = _a.isFocused;\n    var _b = this.props,\n        className = _b.className,\n        inputProps = _b.inputProps,\n        disabled = _b.disabled,\n        selectionAriaLabel = _b.selectionAriaLabel,\n        _c = _b.selectionRole,\n        selectionRole = _c === void 0 ? 'list' : _c,\n        theme = _b.theme,\n        styles = _b.styles;\n    var suggestionsVisible = !!this.state.suggestionsVisible;\n    var suggestionsAvailable = suggestionsVisible ? this._ariaMap.suggestionList : undefined; // TODO\n    // Clean this up by leaving only the first part after removing support for SASS.\n    // Currently we can not remove the SASS styles from BasePicker class because it\n    // might be used by consumers who created custom pickers from extending from\n    // this base class and have not used the new 'styles' prop.\n    // We check for 'styles' prop which is going to be injected by the 'styled' HOC\n    // for every other already existing picker variant (PeoplePicker, TagPicker)\n    // so that we can use the CSS-in-JS styles. If the check fails (ex: custom picker),\n    // then we just use the old SASS styles instead.\n\n    var classNames = styles ? getClassNames(styles, {\n      theme: theme,\n      className: className,\n      isFocused: isFocused,\n      inputClassName: inputProps && inputProps.className\n    }) : {\n      root: css('ms-BasePicker', className ? className : ''),\n      text: css('ms-BasePicker-text', legacyStyles.pickerText, this.state.isFocused && legacyStyles.inputFocused, disabled && legacyStyles.inputDisabled),\n      itemsWrapper: legacyStyles.pickerItems,\n      input: css('ms-BasePicker-input', legacyStyles.pickerInput, inputProps && inputProps.className),\n      screenReaderText: legacyStyles.screenReaderOnly\n    };\n    var comboLabel = this.props['aria-label'] || (inputProps === null || inputProps === void 0 ? void 0 : inputProps['aria-label']);\n    return React.createElement(\"div\", {\n      ref: this.root,\n      onBlur: this.onBlur,\n      onFocus: this.onFocus\n    }, React.createElement(\"div\", {\n      className: classNames.root,\n      onKeyDown: this.onKeyDown\n    }, this.renderCustomAlert(classNames.screenReaderText), React.createElement(\"div\", {\n      className: classNames.text,\n      \"aria-owns\": suggestionsAvailable\n    }, React.createElement(Autofill, __assign({}, inputProps, {\n      className: classNames.input,\n      componentRef: this.input,\n      onFocus: this.onInputFocus,\n      onBlur: this.onInputBlur,\n      onClick: this.onClick,\n      onInputValueChange: this.onInputChange,\n      suggestedDisplayValue: suggestedDisplayValue,\n      \"aria-activedescendant\": suggestionsVisible ? this.getActiveDescendant() : undefined,\n      \"aria-controls\": suggestionsAvailable,\n      \"aria-expanded\": suggestionsVisible,\n      \"aria-haspopup\": \"listbox\",\n      \"aria-label\": comboLabel,\n      role: \"combobox\",\n      id: (inputProps === null || inputProps === void 0 ? void 0 : inputProps.id) ? inputProps.id : this._ariaMap.combobox,\n      disabled: disabled,\n      onInputChange: this.props.onInputChange\n    })))), this.renderSuggestions(), React.createElement(SelectionZone, {\n      selection: this.selection,\n      selectionMode: SelectionMode.single\n    }, React.createElement(\"div\", {\n      id: this._ariaMap.selectedItems,\n      className: \"ms-BasePicker-selectedItems\" // just a className hook without any styles applied to it.\n      ,\n      role: selectionRole,\n      \"aria-label\": selectionAriaLabel || comboLabel\n    }, this.renderItems())));\n  };\n\n  BasePickerListBelow.prototype.onBackspace = function (ev) {// override the existing backspace method to not do anything because the list items appear below.\n  };\n\n  return BasePickerListBelow;\n}(BasePicker);\n\nexport { BasePickerListBelow };","map":{"version":3,"mappings":"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","names":["React","Async","KeyCodes","css","elementContains","format","getId","classNamesFunction","styled","initializeComponentRef","Callout","Selection","SelectionZone","SelectionMode","DirectionalHint","Suggestions","getStyles","suggestionsStyles","SuggestionsController","ValidationState","Autofill","stylesImport","legacyStyles","getClassNames","getStyledSuggestions","suggestionsType","undefined","scope","__extends","basePickerProps","_super","_this","createRef","SuggestionOfProperType","ev","selectItemFunction","addItemOnDismiss","props","onDismiss","suggestionStore","currentSuggestion","item","defaultPrevented","canAddItems","hasSelectedSuggestion","state","suggestedDisplayValue","addItemByIndex","currentPromise","then","setState","suggestionsVisible","keyCode","resetFocus","suggestions","length","up","setSelectedSuggestion","down","value","updateValue","moreSuggestionsAvailable","isMostRecentlyUsedVisible","index","onRemoveSuggestion","removeSuggestion","selection","setAllSelected","isFocused","_userTriggeredSuggestions","inputProps","onFocus","onBlur","relatedTarget","document","activeElement","root","current","items","onClick","button","which","escape","preventDefault","stopPropagation","tab","enter","suggestionElement","hasSuggestedActionSelected","executeSelectedAction","shiftKey","completeSuggestion","_completeGenericSuggestion","backspace","disabled","onBackspace","del","input","target","inputElement","currentIndex","forceUpdate","tryHandleKeyDown","hasSuggestedAction","focusAboveSuggestions","deselectAllSuggestions","previousSuggestion","onSuggestionSelect","focusBelowSuggestions","nextSuggestion","changedItem","newItems","_updateSelectedItems","isSearching","onGetMoreResults","suggestionsArray","suggestionsPromiseLike","Array","isArray","updateSuggestions","newSuggestions","focus","isResultsFooterVisible","addItem","clear","completeSelection","getSuggestionAtIndex","processedItem","onItemSelected","processedItemObject","processedItemPromiseLike","resolvedProcessedItem","concat","selectionRemoved","indexOf","slice","itemsToRemove","filter","updatedValue","onResolveSuggestions","updateSuggestionsList","onValidateInput","invalid","createGenericItem","itemToConvert","createGenericSuggestion","onEmptyInputFocus","_onResolveSuggestions","_async","selectedItems","defaultSelectedItems","_id","_ariaMap","selectedSuggestionAlert","suggestionList","combobox","onSelectionChanged","onSelectionChange","setItems","selectedIndices","BasePicker","newProps","Object","debounce","resolveDelay","oldProps","oldState","currentSelectedIndex","getSelectedIndices","setIndexSelected","dispose","forceComplete","className","selectionAriaLabel","_c","selectionRole","theme","styles","suggestionsAvailable","classNames","inputClassName","text","pickerText","inputFocused","itemsWrapper","pickerItems","pickerInput","screenReaderText","screenReaderOnly","comboLabel","ref","onKeyDown","onWrapperClick","renderCustomAlert","id","hidden","selectionMode","multiple","role","renderItems","__assign","spellCheck","componentRef","onInputFocus","onInputBlur","onInputValueChange","onInputChange","getActiveDescendant","renderSuggestions","itemLimit","StyledTypedSuggestions","_styledSuggestions","isBeakVisible","gapSpace","dismissSuggestions","directionalHint","bottomLeftEdge","directionalHintForRTL","bottomRightEdge","pickerCalloutProps","onRenderSuggestion","onRenderSuggestionsItem","onSuggestionClick","onSuggestionRemove","getSuggestions","isLoading","suggestionsLoading","refocusSuggestions","removeSuggestionAriaLabel","removeButtonAriaLabel","suggestionsListId","pickerSuggestionsProps","removeButtonIconProps","onRenderItem","map","key","selected","onRemoveItem","removeItem","onItemChange","newEl","querySelectorAll","Math","min","currentValue","itemValue","_getTextFromItem","emptyResolveSuggestions","onEmptyResolveSuggestions","_updateAndResolveValue","_getShowSuggestions","onChange","isValueSelected","cursorLocation","getSelectedCount","removeItems","getSelection","_a","suggestionAlertClassName","enableSelectedSuggestionAlert","selectedSuggestion","selectedSuggestionAlertText","ariaLabel","alertClassName","suggestionRemovedText","removedItemText","itemName","getSuggestionsAlert","resolveNewValue","_onSelectedItemsUpdated","areSuggestionsVisible","getTextFromItem","Component","BasePickerListBelow","inputDisabled","single"],"sources":["/home/runner/work/Reaction/Reaction/employee-info/node_modules/@fluentui/react/lib/components/src/components/pickers/BasePicker.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  KeyCodes,\n  css,\n  elementContains,\n  format,\n  getId,\n  classNamesFunction,\n  styled,\n  initializeComponentRef,\n} from '../../Utilities';\nimport { Callout } from '../../Callout';\nimport { Selection, SelectionZone, SelectionMode } from '../../utilities/selection/index';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { Suggestions } from './Suggestions/Suggestions';\nimport { getStyles as suggestionsStyles } from './Suggestions/Suggestions.styles';\nimport { SuggestionsController } from './Suggestions/SuggestionsController';\nimport { ValidationState } from './BasePicker.types';\nimport { Autofill } from '../Autofill/index';\nimport * as stylesImport from './BasePicker.scss';\nimport type { IProcessedStyleSet } from '../../Styling';\nimport type {\n  ISuggestions,\n  ISuggestionsProps,\n  ISuggestionsStyleProps,\n  ISuggestionsStyles,\n} from './Suggestions/Suggestions.types';\nimport type { IBasePicker, IBasePickerProps, IBasePickerStyleProps, IBasePickerStyles } from './BasePicker.types';\nimport type { IAutofill } from '../Autofill/index';\nimport type { IPickerItemProps } from './PickerItem.types';\n\nconst legacyStyles: any = stylesImport;\n\nexport interface IBasePickerState<T> {\n  items?: any;\n  suggestedDisplayValue?: string;\n  moreSuggestionsAvailable?: boolean;\n  isFocused?: boolean;\n  isSearching?: boolean;\n  isMostRecentlyUsedVisible?: boolean;\n  suggestionsVisible?: boolean;\n  suggestionsLoading?: boolean;\n  isResultsFooterVisible?: boolean;\n  selectedIndices?: number[];\n  selectionRemoved?: T;\n}\n\n/**\n * Aria id's for internal picker components\n * {@docCategory Pickers}\n */\nexport type IPickerAriaIds = {\n  /**\n   * Aria id for selected suggestion alert component\n   */\n  selectedSuggestionAlert: string;\n  /**\n   * Aria id for selected items container component\n   */\n  selectedItems: string;\n  /**\n   * Aria id for suggestions list component\n   */\n  suggestionList: string;\n  /**\n   * Aria id for element with role=combobox\n   */\n  combobox: string;\n};\n\nconst getClassNames = classNamesFunction<IBasePickerStyleProps, IBasePickerStyles>();\n\n/**\n * Should be removed once new picker without inheritance is created\n */\nfunction getStyledSuggestions<T>(suggestionsType: new (props: ISuggestionsProps<T>) => Suggestions<T>) {\n  return styled<ISuggestionsProps<any>, ISuggestionsStyleProps, ISuggestionsStyles>(\n    suggestionsType,\n    suggestionsStyles,\n    undefined,\n    {\n      scope: 'Suggestions',\n    },\n  );\n}\n\n/**\n * {@docCategory Pickers}\n */\nexport class BasePicker<T, P extends IBasePickerProps<T>>\n  extends React.Component<P, IBasePickerState<T>>\n  implements IBasePicker<T> {\n  // Refs\n  protected root = React.createRef<HTMLDivElement>();\n  protected input = React.createRef<IAutofill>();\n  protected suggestionElement = React.createRef<ISuggestions<T>>();\n  protected selection: Selection;\n  protected suggestionStore: SuggestionsController<T>;\n  /**\n   * @deprecated this is no longer necessary as typescript now supports generic elements\n   */\n  protected SuggestionOfProperType = Suggestions as new (props: ISuggestionsProps<T>) => Suggestions<T>;\n  protected currentPromise: PromiseLike<any> | undefined;\n  protected _ariaMap: IPickerAriaIds;\n  // eslint-disable-next-line deprecation/deprecation\n  private _styledSuggestions = getStyledSuggestions(this.SuggestionOfProperType);\n  private _id: string;\n  private _async: Async;\n\n  public static getDerivedStateFromProps(newProps: IBasePickerProps<any>) {\n    if (newProps.selectedItems) {\n      return { items: newProps.selectedItems };\n    }\n    return null;\n  }\n\n  constructor(basePickerProps: P) {\n    super(basePickerProps);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n\n    const items: T[] = basePickerProps.selectedItems || basePickerProps.defaultSelectedItems || [];\n\n    this._id = getId();\n    this._ariaMap = {\n      selectedItems: `selected-items-${this._id}`,\n      selectedSuggestionAlert: `selected-suggestion-alert-${this._id}`,\n      suggestionList: `suggestion-list-${this._id}`,\n      combobox: `combobox-${this._id}`,\n    };\n    this.suggestionStore = new SuggestionsController<T>();\n    this.selection = new Selection({ onSelectionChanged: () => this.onSelectionChange() });\n    this.selection.setItems(items);\n    this.state = {\n      items: items,\n      suggestedDisplayValue: '',\n      isMostRecentlyUsedVisible: false,\n      moreSuggestionsAvailable: false,\n      isFocused: false,\n      isSearching: false,\n      selectedIndices: [],\n      selectionRemoved: undefined,\n    };\n  }\n\n  public get items(): T[] {\n    return this.state.items;\n  }\n\n  public componentDidMount(): void {\n    this.selection.setItems(this.state.items);\n    this._onResolveSuggestions = this._async.debounce(this._onResolveSuggestions, this.props.resolveDelay);\n  }\n\n  public componentDidUpdate(oldProps: P, oldState: IBasePickerState<T>) {\n    if (this.state.items && this.state.items !== oldState.items) {\n      const currentSelectedIndex = this.selection.getSelectedIndices()[0];\n      this.selection.setItems(this.state.items);\n      if (this.state.isFocused) {\n        // Reset focus and selection so that selected item stays in sync if something\n        // has been removed\n        if (this.state.items.length < oldState.items.length) {\n          this.selection.setIndexSelected(currentSelectedIndex, false, true);\n          this.resetFocus(currentSelectedIndex);\n        }\n        // Reset focus to last item if the input is removed\n        else if (this.state.items.length > oldState.items.length && !this.canAddItems()) {\n          this.resetFocus(this.state.items.length - 1);\n        }\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    if (this.currentPromise) {\n      this.currentPromise = undefined;\n    }\n    this._async.dispose();\n  }\n\n  public focus() {\n    if (this.input.current) {\n      this.input.current.focus();\n    }\n  }\n\n  public focusInput() {\n    if (this.input.current) {\n      this.input.current.focus();\n    }\n  }\n\n  public dismissSuggestions = (ev?: any): void => {\n    const selectItemFunction = () => {\n      let addItemOnDismiss: boolean | void = true;\n      if (this.props.onDismiss) {\n        addItemOnDismiss = this.props.onDismiss(\n          ev,\n          this.suggestionStore.currentSuggestion ? this.suggestionStore.currentSuggestion.item : undefined,\n        );\n      }\n\n      if (!ev || (ev && !ev.defaultPrevented)) {\n        // Select the first suggestion if one is available and permitted by onDismiss when user leaves.\n        if (\n          addItemOnDismiss !== false &&\n          this.canAddItems() &&\n          this.suggestionStore.hasSelectedSuggestion() &&\n          this.state.suggestedDisplayValue\n        ) {\n          this.addItemByIndex(0);\n        }\n      }\n    };\n\n    if (this.currentPromise) {\n      this.currentPromise.then(() => selectItemFunction());\n    } else {\n      selectItemFunction();\n    }\n\n    this.setState({ suggestionsVisible: false });\n  };\n\n  public completeSuggestion(forceComplete?: boolean) {\n    if (this.suggestionStore.hasSelectedSuggestion() && this.input.current) {\n      this.completeSelection(this.suggestionStore.currentSuggestion!.item);\n    } else if (forceComplete) {\n      this._completeGenericSuggestion();\n    }\n  }\n\n  public refocusSuggestions = (keyCode: KeyCodes): void => {\n    this.resetFocus();\n    if (this.suggestionStore.suggestions && this.suggestionStore.suggestions.length > 0) {\n      if (keyCode === KeyCodes.up) {\n        this.suggestionStore.setSelectedSuggestion(this.suggestionStore.suggestions.length - 1);\n      } else if (keyCode === KeyCodes.down) {\n        this.suggestionStore.setSelectedSuggestion(0);\n      }\n    }\n  };\n\n  public render(): JSX.Element {\n    const { suggestedDisplayValue, isFocused, items } = this.state;\n    const { className, inputProps, disabled, selectionAriaLabel, selectionRole = 'list', theme, styles } = this.props;\n\n    const suggestionsVisible = !!this.state.suggestionsVisible;\n    const suggestionsAvailable = suggestionsVisible ? this._ariaMap.suggestionList : undefined;\n    // TODO\n    // Clean this up by leaving only the first part after removing support for SASS.\n    // Currently we can not remove the SASS styles from BasePicker class because it\n    // might be used by consumers who created custom pickers from extending from\n    // this base class and have not used the new 'styles' prop.\n    // We check for 'styles' prop which is going to be injected by the 'styled' HOC\n    // for every other already existing picker variant (PeoplePicker, TagPicker)\n    // so that we can use the CSS-in-JS styles. If the check fails (ex: custom picker),\n    // then we just use the old SASS styles instead.\n    const classNames: Partial<IProcessedStyleSet<IBasePickerStyles>> = styles\n      ? getClassNames(styles, {\n          theme,\n          className,\n          isFocused,\n          disabled,\n          inputClassName: inputProps && inputProps.className,\n        })\n      : {\n          root: css('ms-BasePicker', className ? className : ''),\n          text: css('ms-BasePicker-text', legacyStyles.pickerText, this.state.isFocused && legacyStyles.inputFocused),\n          itemsWrapper: legacyStyles.pickerItems,\n          input: css('ms-BasePicker-input', legacyStyles.pickerInput, inputProps && inputProps.className),\n          screenReaderText: legacyStyles.screenReaderOnly,\n        };\n\n    const comboLabel = this.props['aria-label'] || inputProps?.['aria-label'];\n\n    // selectionAriaLabel is contained in a separate <span> rather than an aria-label on the items list\n    // because if the items list has an aria-label, the aria-describedby on the input will only read\n    // that label instead of all the selected items. Using aria-labelledby instead fixes this, since\n    // aria-describedby and aria-labelledby will not follow a second aria-labelledby\n    return (\n      <div\n        ref={this.root}\n        className={classNames.root}\n        onKeyDown={this.onKeyDown}\n        onFocus={this.onFocus}\n        onBlur={this.onBlur}\n        onClick={this.onWrapperClick}\n      >\n        {this.renderCustomAlert(classNames.screenReaderText)}\n        <span id={`${this._ariaMap.selectedItems}-label`} hidden>\n          {selectionAriaLabel || comboLabel}\n        </span>\n        <SelectionZone selection={this.selection} selectionMode={SelectionMode.multiple}>\n          <div className={classNames.text} aria-owns={suggestionsAvailable}>\n            {items.length > 0 && (\n              <span\n                id={this._ariaMap.selectedItems}\n                className={classNames.itemsWrapper}\n                role={selectionRole}\n                aria-labelledby={`${this._ariaMap.selectedItems}-label`}\n              >\n                {this.renderItems()}\n              </span>\n            )}\n            {this.canAddItems() && (\n              <Autofill\n                spellCheck={false}\n                {...(inputProps as any)}\n                className={classNames.input}\n                componentRef={this.input}\n                id={inputProps?.id ? inputProps.id : this._ariaMap.combobox}\n                onClick={this.onClick}\n                onFocus={this.onInputFocus}\n                onBlur={this.onInputBlur}\n                onInputValueChange={this.onInputChange}\n                suggestedDisplayValue={suggestedDisplayValue}\n                aria-activedescendant={suggestionsVisible ? this.getActiveDescendant() : undefined}\n                aria-controls={suggestionsAvailable}\n                aria-describedby={items.length > 0 ? this._ariaMap.selectedItems : undefined}\n                aria-expanded={suggestionsVisible}\n                aria-haspopup=\"listbox\"\n                aria-label={comboLabel}\n                role=\"combobox\"\n                disabled={disabled}\n                onInputChange={this.props.onInputChange}\n              />\n            )}\n          </div>\n        </SelectionZone>\n        {this.renderSuggestions()}\n      </div>\n    );\n  }\n\n  protected canAddItems(): boolean {\n    const { items } = this.state;\n    const { itemLimit } = this.props;\n    return itemLimit === undefined || items.length < itemLimit;\n  }\n\n  protected renderSuggestions(): JSX.Element | null {\n    const StyledTypedSuggestions: React.FunctionComponent<ISuggestionsProps<T>> = this._styledSuggestions;\n\n    return this.state.suggestionsVisible && this.input ? (\n      <Callout\n        isBeakVisible={false}\n        gapSpace={5}\n        target={this.input.current ? this.input.current.inputElement : undefined}\n        onDismiss={this.dismissSuggestions}\n        directionalHint={DirectionalHint.bottomLeftEdge}\n        directionalHintForRTL={DirectionalHint.bottomRightEdge}\n        {...this.props.pickerCalloutProps}\n      >\n        <StyledTypedSuggestions\n          // Assumed to set in derived component's defaultProps\n          onRenderSuggestion={this.props.onRenderSuggestionsItem!}\n          onSuggestionClick={this.onSuggestionClick}\n          onSuggestionRemove={this.onSuggestionRemove}\n          suggestions={this.suggestionStore.getSuggestions()}\n          componentRef={this.suggestionElement}\n          onGetMoreResults={this.onGetMoreResults}\n          moreSuggestionsAvailable={this.state.moreSuggestionsAvailable}\n          isLoading={this.state.suggestionsLoading}\n          isSearching={this.state.isSearching}\n          isMostRecentlyUsedVisible={this.state.isMostRecentlyUsedVisible}\n          isResultsFooterVisible={this.state.isResultsFooterVisible}\n          refocusSuggestions={this.refocusSuggestions}\n          removeSuggestionAriaLabel={this.props.removeButtonAriaLabel}\n          suggestionsListId={this._ariaMap.suggestionList}\n          createGenericItem={this._completeGenericSuggestion}\n          {...this.props.pickerSuggestionsProps}\n        />\n      </Callout>\n    ) : null;\n  }\n\n  protected renderItems(): JSX.Element[] {\n    const { disabled, removeButtonAriaLabel, removeButtonIconProps } = this.props;\n    const onRenderItem = this.props.onRenderItem as (props: IPickerItemProps<T>) => JSX.Element;\n\n    const { items, selectedIndices } = this.state;\n    return items.map((item: any, index: number) =>\n      onRenderItem({\n        item,\n        index,\n        key: item.key ? item.key : index,\n        selected: selectedIndices!.indexOf(index) !== -1,\n        onRemoveItem: () => this.removeItem(item),\n        disabled: disabled,\n        onItemChange: this.onItemChange,\n        removeButtonAriaLabel: removeButtonAriaLabel,\n        removeButtonIconProps,\n      }),\n    );\n  }\n\n  protected resetFocus(index?: number) {\n    const { items } = this.state;\n\n    if (items.length && index! >= 0) {\n      const newEl: HTMLElement | null =\n        this.root.current &&\n        (this.root.current.querySelectorAll('[data-selection-index]')[\n          Math.min(index!, items.length - 1)\n        ] as HTMLElement | null);\n      if (newEl) {\n        newEl.focus();\n      }\n    } else if (!this.canAddItems()) {\n      this.resetFocus(items.length - 1);\n    } else {\n      if (this.input.current) {\n        this.input.current.focus();\n      }\n    }\n  }\n\n  protected onSuggestionSelect() {\n    if (this.suggestionStore.currentSuggestion) {\n      const currentValue: string = this.input.current ? this.input.current.value : '';\n      const itemValue: string = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, currentValue);\n      this.setState({ suggestedDisplayValue: itemValue });\n    }\n  }\n\n  protected onSelectionChange() {\n    this.setState({\n      selectedIndices: this.selection.getSelectedIndices(),\n    });\n  }\n\n  protected updateSuggestions(suggestions: any[]) {\n    this.suggestionStore.updateSuggestions(suggestions, 0);\n    this.forceUpdate();\n  }\n\n  /**\n   * Only to be called when there is nothing in the input. Checks to see if the consumer has\n   * provided a function to resolve suggestions\n   */\n  protected onEmptyInputFocus() {\n    const emptyResolveSuggestions = this.props.onEmptyResolveSuggestions\n      ? this.props.onEmptyResolveSuggestions\n      : // eslint-disable-next-line deprecation/deprecation\n        this.props.onEmptyInputFocus;\n\n    // Only attempt to resolve suggestions if it exists\n    if (emptyResolveSuggestions) {\n      const suggestions = emptyResolveSuggestions(this.state.items);\n\n      this.updateSuggestionsList(suggestions);\n\n      this.setState({\n        isMostRecentlyUsedVisible: true,\n        suggestionsVisible: true,\n        moreSuggestionsAvailable: false,\n      });\n    }\n  }\n\n  protected updateValue(updatedValue: string) {\n    this._onResolveSuggestions(updatedValue);\n  }\n\n  protected updateSuggestionsList(suggestions: T[] | PromiseLike<T[]>, updatedValue?: string) {\n    // Check to see if the returned value is an array, if it is then just pass it into the next function .\n    // If the returned value is not an array then check to see if it's a promise or PromiseLike.\n    // If it is then resolve it asynchronously.\n    if (Array.isArray(suggestions)) {\n      this._updateAndResolveValue(updatedValue, suggestions);\n    } else if (suggestions && (suggestions as PromiseLike<T[]>).then) {\n      this.setState({\n        suggestionsLoading: true,\n      });\n\n      // Clear suggestions\n      this.suggestionStore.updateSuggestions([]);\n\n      if (updatedValue !== undefined) {\n        this.setState({\n          suggestionsVisible: this._getShowSuggestions(),\n        });\n      } else {\n        this.setState({\n          suggestionsVisible: this.input.current! && this.input.current!.inputElement === document.activeElement,\n        });\n      }\n\n      // Ensure that the promise will only use the callback if it was the most recent one.\n      this.currentPromise = suggestions;\n      suggestions.then((newSuggestions: T[]) => {\n        if (suggestions === this.currentPromise) {\n          this._updateAndResolveValue(updatedValue, newSuggestions);\n        }\n      });\n    }\n  }\n\n  protected resolveNewValue(updatedValue: string, suggestions: T[]) {\n    this.updateSuggestions(suggestions);\n    let itemValue: string | undefined = undefined;\n\n    if (this.suggestionStore.currentSuggestion) {\n      itemValue = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, updatedValue);\n    }\n\n    // Only set suggestionloading to false after there has been time for the new suggestions to flow\n    // to the suggestions list. This is to ensure that the suggestions are available before aria-activedescendant\n    // is set so that screen readers will read out the first selected option.\n    this.setState(\n      {\n        suggestedDisplayValue: itemValue,\n        suggestionsVisible: this._getShowSuggestions(),\n      },\n      () => this.setState({ suggestionsLoading: false }),\n    );\n  }\n\n  protected onChange(items?: T[]) {\n    if (this.props.onChange) {\n      (this.props.onChange as any)(items);\n    }\n  }\n\n  protected onInputChange = (value: string): void => {\n    this.updateValue(value);\n    this.setState({\n      moreSuggestionsAvailable: true,\n      isMostRecentlyUsedVisible: false,\n    });\n  };\n\n  protected onSuggestionClick = (ev: React.MouseEvent<HTMLElement>, item: any, index: number): void => {\n    this.addItemByIndex(index);\n  };\n\n  protected onSuggestionRemove = (ev: React.MouseEvent<HTMLElement>, item: T, index: number): void => {\n    if (this.props.onRemoveSuggestion) {\n      this.props.onRemoveSuggestion(item);\n    }\n    this.suggestionStore.removeSuggestion(index);\n  };\n\n  protected onInputFocus = (ev: React.FocusEvent<HTMLInputElement | Autofill>): void => {\n    this.selection.setAllSelected(false);\n    // Only trigger all of the focus if this component isn't already focused.\n    // For example when an item is selected or removed from the selected list it should be treated\n    // as though the input is still focused.\n    if (!this.state.isFocused) {\n      this._userTriggeredSuggestions();\n\n      if (this.props.inputProps && this.props.inputProps.onFocus) {\n        this.props.inputProps.onFocus(ev as React.FocusEvent<HTMLInputElement>);\n      }\n    }\n  };\n\n  protected onInputBlur = (ev: React.FocusEvent<HTMLInputElement | Autofill>): void => {\n    if (this.props.inputProps && this.props.inputProps.onBlur) {\n      this.props.inputProps.onBlur(ev as React.FocusEvent<HTMLInputElement>);\n    }\n  };\n\n  protected onBlur = (ev: React.FocusEvent<HTMLElement | Autofill>): void => {\n    if (this.state.isFocused) {\n      // Only blur the entire component if an unrelated element gets focus.\n      // Otherwise treat it as though it still has focus.\n      // Do nothing if the blur is coming from something\n      // inside the comboBox root or the comboBox menu since\n      // it we are not really bluring from the whole comboBox\n      let relatedTarget: EventTarget | null = ev.relatedTarget;\n\n      if (ev.relatedTarget === null) {\n        // In IE11, due to lack of support, event.relatedTarget is always\n        // null making every onBlur call to be \"outside\" of the ComboBox\n        // even when it's not. Using document.activeElement is another way\n        // for us to be able to get what the relatedTarget without relying\n        // on the event\n        relatedTarget = document.activeElement;\n      }\n      if (relatedTarget && !elementContains(this.root.current!, relatedTarget as HTMLElement)) {\n        this.setState({ isFocused: false });\n        if (this.props.onBlur) {\n          this.props.onBlur(ev as React.FocusEvent<HTMLInputElement>);\n        }\n      }\n    }\n  };\n\n  /**\n   * Resets focus to last element in wrapper div if clicking back into Picker that has hit item limit\n   */\n  protected onWrapperClick = (ev: React.MouseEvent<HTMLInputElement>): void => {\n    if (!this.canAddItems()) {\n      this.resetFocus(this.state.items.length - 1);\n    }\n  };\n\n  /**\n   * Reveals suggestions any time the user clicks on the input element\n   * without shifting focus.\n   */\n  protected onClick = (ev: React.MouseEvent<HTMLInputElement>): void => {\n    if (this.props.inputProps !== undefined && this.props.inputProps.onClick !== undefined) {\n      this.props.inputProps.onClick(ev);\n    }\n\n    // Only primary (left) clicks show suggestions.\n    if (ev.button === 0) {\n      this._userTriggeredSuggestions();\n    }\n  };\n\n  protected onFocus = () => {\n    if (!this.state.isFocused) {\n      this.setState({ isFocused: true });\n    }\n  };\n\n  protected onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    // eslint-disable-next-line deprecation/deprecation\n    const keyCode = ev.which;\n    switch (keyCode) {\n      case KeyCodes.escape:\n        if (this.state.suggestionsVisible) {\n          this.setState({ suggestionsVisible: false });\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n        break;\n\n      case KeyCodes.tab:\n      case KeyCodes.enter:\n        if (this.suggestionElement.current && this.suggestionElement.current.hasSuggestedActionSelected()) {\n          this.suggestionElement.current.executeSelectedAction();\n        } else if (!ev.shiftKey && this.suggestionStore.hasSelectedSuggestion() && this.state.suggestionsVisible) {\n          this.completeSuggestion();\n          ev.preventDefault();\n          ev.stopPropagation();\n        } else {\n          this._completeGenericSuggestion();\n        }\n\n        break;\n\n      case KeyCodes.backspace:\n        if (!this.props.disabled) {\n          this.onBackspace(ev);\n        }\n        ev.stopPropagation();\n        break;\n\n      case KeyCodes.del:\n        if (!this.props.disabled) {\n          if (\n            this.input.current &&\n            ev.target === this.input.current.inputElement &&\n            this.state.suggestionsVisible &&\n            this.suggestionStore.currentIndex !== -1\n          ) {\n            if (this.props.onRemoveSuggestion) {\n              this.props.onRemoveSuggestion(this.suggestionStore.currentSuggestion!.item);\n            }\n            this.suggestionStore.removeSuggestion(this.suggestionStore.currentIndex);\n            this.forceUpdate();\n          } else {\n            this.onBackspace(ev);\n          }\n        }\n        ev.stopPropagation();\n        break;\n\n      case KeyCodes.up:\n        if (this.input.current && ev.target === this.input.current.inputElement && this.state.suggestionsVisible) {\n          if (\n            this.suggestionElement.current &&\n            this.suggestionElement.current.tryHandleKeyDown(keyCode, this.suggestionStore.currentIndex)\n          ) {\n            ev.preventDefault();\n            ev.stopPropagation();\n            this.forceUpdate();\n          } else {\n            if (\n              this.suggestionElement.current &&\n              this.suggestionElement.current.hasSuggestedAction() &&\n              this.suggestionStore.currentIndex === 0\n            ) {\n              ev.preventDefault();\n              ev.stopPropagation();\n              this.suggestionElement.current.focusAboveSuggestions();\n              this.suggestionStore.deselectAllSuggestions();\n              this.forceUpdate();\n            } else {\n              if (this.suggestionStore.previousSuggestion()) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                this.onSuggestionSelect();\n              }\n            }\n          }\n        }\n        break;\n\n      case KeyCodes.down:\n        if (this.input.current && ev.target === this.input.current.inputElement && this.state.suggestionsVisible) {\n          if (\n            this.suggestionElement.current &&\n            this.suggestionElement.current.tryHandleKeyDown(keyCode, this.suggestionStore.currentIndex)\n          ) {\n            ev.preventDefault();\n            ev.stopPropagation();\n            this.forceUpdate();\n          } else {\n            if (\n              this.suggestionElement.current &&\n              this.suggestionElement.current.hasSuggestedAction() &&\n              this.suggestionStore.currentIndex + 1 === this.suggestionStore.suggestions.length\n            ) {\n              ev.preventDefault();\n              ev.stopPropagation();\n              this.suggestionElement.current.focusBelowSuggestions();\n              this.suggestionStore.deselectAllSuggestions();\n              this.forceUpdate();\n            } else {\n              if (this.suggestionStore.nextSuggestion()) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                this.onSuggestionSelect();\n              }\n            }\n          }\n        }\n        break;\n    }\n  };\n\n  protected onItemChange = (changedItem: T, index: number): void => {\n    const { items } = this.state;\n\n    if (index >= 0) {\n      const newItems: T[] = items;\n      newItems[index] = changedItem;\n\n      this._updateSelectedItems(newItems);\n    }\n  };\n\n  protected onGetMoreResults = (): void => {\n    this.setState(\n      {\n        isSearching: true,\n      },\n      () => {\n        if (this.props.onGetMoreResults && this.input.current) {\n          const suggestions: T[] | PromiseLike<T[]> = (this.props.onGetMoreResults as any)(\n            this.input.current.value,\n            this.state.items,\n          );\n          const suggestionsArray: T[] = suggestions as T[];\n          const suggestionsPromiseLike: PromiseLike<T[]> = suggestions as PromiseLike<T[]>;\n\n          if (Array.isArray(suggestionsArray)) {\n            this.updateSuggestions(suggestionsArray);\n            this.setState({ isSearching: false });\n          } else if (suggestionsPromiseLike.then) {\n            suggestionsPromiseLike.then((newSuggestions: T[]) => {\n              this.updateSuggestions(newSuggestions);\n              this.setState({ isSearching: false });\n            });\n          }\n        } else {\n          this.setState({ isSearching: false });\n        }\n\n        if (this.input.current) {\n          this.input.current.focus();\n        }\n\n        this.setState({\n          moreSuggestionsAvailable: false,\n          isResultsFooterVisible: true,\n        });\n      },\n    );\n  };\n\n  protected completeSelection = (item: T) => {\n    this.addItem(item);\n    this.updateValue('');\n    if (this.input.current) {\n      this.input.current.clear();\n    }\n    this.setState({ suggestionsVisible: false });\n  };\n\n  protected addItemByIndex = (index: number): void => {\n    this.completeSelection(this.suggestionStore.getSuggestionAtIndex(index).item);\n  };\n\n  protected addItem = (item: T): void => {\n    const processedItem: T | PromiseLike<T> | null = this.props.onItemSelected\n      ? (this.props.onItemSelected as any)(item)\n      : item;\n\n    if (processedItem === null) {\n      return;\n    }\n\n    const processedItemObject: T = processedItem as T;\n    const processedItemPromiseLike: PromiseLike<T> = processedItem as PromiseLike<T>;\n\n    if (processedItemPromiseLike && processedItemPromiseLike.then) {\n      processedItemPromiseLike.then((resolvedProcessedItem: T) => {\n        const newItems: T[] = this.state.items.concat([resolvedProcessedItem]);\n        this._updateSelectedItems(newItems);\n      });\n    } else {\n      const newItems: T[] = this.state.items.concat([processedItemObject]);\n      this._updateSelectedItems(newItems);\n    }\n    this.setState({ suggestedDisplayValue: '', selectionRemoved: undefined });\n  };\n\n  protected removeItem = (item: T): void => {\n    const { items } = this.state;\n    const index: number = items.indexOf(item);\n\n    if (index >= 0) {\n      const newItems: T[] = items.slice(0, index).concat(items.slice(index + 1));\n      this.setState({ selectionRemoved: item });\n      this._updateSelectedItems(newItems);\n    }\n  };\n\n  protected removeItems = (itemsToRemove: any[]): void => {\n    const { items } = this.state;\n    const newItems: T[] = items.filter((item: any) => itemsToRemove.indexOf(item) === -1);\n\n    this._updateSelectedItems(newItems);\n  };\n\n  // This is protected because we may expect the backspace key to work differently in a different kind of picker.\n  // This lets the subclass override it and provide it's own onBackspace. For an example see the BasePickerListBelow\n  protected onBackspace(ev: React.KeyboardEvent<HTMLElement>) {\n    if (\n      (this.state.items.length && !this.input.current) ||\n      (this.input.current && !this.input.current.isValueSelected && this.input.current.cursorLocation === 0)\n    ) {\n      if (this.selection.getSelectedCount() > 0) {\n        this.removeItems(this.selection.getSelection());\n      } else {\n        this.removeItem(this.state.items[this.state.items.length - 1]);\n      }\n    }\n  }\n\n  /**\n   * @deprecated this is no longer necessary as focuszone has been removed\n   */\n  protected _shouldFocusZoneEnterInnerZone = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    // If suggestions are shown const up/down keys control them, otherwise allow them through to control the focusZone.\n    if (this.state.suggestionsVisible) {\n      // eslint-disable-next-line deprecation/deprecation\n      switch (ev.which) {\n        case KeyCodes.up:\n        case KeyCodes.down:\n          return true;\n      }\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (ev.which === KeyCodes.enter) {\n      return true;\n    }\n\n    return false;\n  };\n\n  protected getActiveDescendant() {\n    if (this.state.suggestionsLoading) {\n      return undefined;\n    }\n\n    const currentIndex = this.suggestionStore.currentIndex;\n\n    if (currentIndex < 0) {\n      // if the suggestions element has actions and the currentIndex does not point to a suggestion,\n      // return the action id\n      if (this.suggestionElement.current?.hasSuggestedAction()) {\n        return 'sug-selectedAction';\n      }\n\n      // If there are no suggestions and no action suggested, then return the ID for the no results found.\n      if (this.suggestionStore.suggestions.length === 0) {\n        return 'sug-noResultsFound';\n      }\n\n      return undefined;\n    } else {\n      return `sug-${currentIndex}`;\n    }\n  }\n\n  /** @deprecated use renderCustomAlert instead */\n  protected getSuggestionsAlert(suggestionAlertClassName: string = legacyStyles.screenReaderOnly) {\n    const currentIndex = this.suggestionStore.currentIndex;\n    if (this.props.enableSelectedSuggestionAlert) {\n      const selectedSuggestion =\n        currentIndex > -1 ? this.suggestionStore.getSuggestionAtIndex(this.suggestionStore.currentIndex) : undefined;\n      const selectedSuggestionAlertText = selectedSuggestion ? selectedSuggestion.ariaLabel : undefined;\n      // keeping the id/className here for legacy support\n      return (\n        <div id={this._ariaMap.selectedSuggestionAlert} className={suggestionAlertClassName}>\n          {`${selectedSuggestionAlertText} `}\n        </div>\n      );\n    }\n  }\n\n  protected renderCustomAlert(alertClassName: string = legacyStyles.screenReaderOnly) {\n    const { suggestionRemovedText = 'removed {0}' } = this.props;\n    let removedItemText = '';\n\n    if (this.state.selectionRemoved) {\n      const itemName = this._getTextFromItem(this.state.selectionRemoved, '');\n      removedItemText = format(suggestionRemovedText, itemName);\n    }\n\n    return (\n      <div className={alertClassName} id={this._ariaMap.selectedSuggestionAlert} aria-live=\"assertive\">\n        {\n          // eslint-disable-next-line deprecation/deprecation\n          this.getSuggestionsAlert(alertClassName)\n        }\n        {removedItemText}\n      </div>\n    );\n  }\n\n  /**\n   * Takes in the current updated value and either resolves it with the new suggestions\n   * or if updated value is undefined then it clears out currently suggested items\n   */\n  private _updateAndResolveValue(updatedValue: string | undefined, newSuggestions: T[]) {\n    if (updatedValue !== undefined) {\n      this.resolveNewValue(updatedValue, newSuggestions);\n    } else {\n      this.suggestionStore.updateSuggestions(newSuggestions, -1);\n      if (this.state.suggestionsLoading) {\n        this.setState({\n          suggestionsLoading: false,\n        });\n      }\n    }\n  }\n\n  /**\n   * Controls what happens whenever there is an action that impacts the selected items.\n   * If `selectedItems` is provided, this will act as a controlled component and it will not update its own state.\n   */\n  private _updateSelectedItems(items: T[]): void {\n    if (this.props.selectedItems) {\n      // If the component is a controlled component then the controlling component will need to add or remove the items.\n      this.onChange(items);\n    } else {\n      this.setState({ items: items }, () => {\n        this._onSelectedItemsUpdated(items);\n      });\n    }\n  }\n\n  private _onSelectedItemsUpdated(items?: T[]): void {\n    this.onChange(items);\n  }\n\n  /**\n   * Suggestions are normally shown after the user updates text and the text\n   * is non-empty, but also when the user clicks on the input element.\n   * @returns True if suggestions should be shown.\n   */\n  private _getShowSuggestions(): boolean {\n    const areSuggestionsVisible =\n      this.input.current !== undefined &&\n      this.input.current !== null &&\n      this.input.current.inputElement === document.activeElement &&\n      this.input.current.value !== '';\n\n    return areSuggestionsVisible;\n  }\n\n  private _onResolveSuggestions = (updatedValue: string): void => {\n    const suggestions: T[] | PromiseLike<T[]> | null = this.props.onResolveSuggestions(updatedValue, this.state.items);\n\n    if (suggestions !== null) {\n      this.updateSuggestionsList(suggestions, updatedValue);\n    }\n  };\n\n  private _completeGenericSuggestion = (): void => {\n    if (\n      this.props.onValidateInput &&\n      this.input.current &&\n      (this.props.onValidateInput as any)(this.input.current.value) !== ValidationState.invalid &&\n      this.props.createGenericItem\n    ) {\n      const itemToConvert = this.props.createGenericItem(\n        this.input.current.value,\n        this.props.onValidateInput(this.input.current.value),\n      );\n      this.suggestionStore.createGenericSuggestion(itemToConvert);\n      this.completeSuggestion();\n    }\n  };\n\n  private _getTextFromItem(item: T, currentValue?: string): string {\n    if (this.props.getTextFromItem) {\n      return (this.props.getTextFromItem as any)(item, currentValue);\n    } else {\n      return '';\n    }\n  }\n\n  /**\n   * This should be called when the user does something other than use text entry to trigger suggestions.\n   *\n   */\n  private _userTriggeredSuggestions = () => {\n    if (!this.state.suggestionsVisible) {\n      const input = this.input.current ? this.input.current.value : '';\n      if (!input) {\n        this.onEmptyInputFocus();\n      } else {\n        if (this.suggestionStore.suggestions.length === 0) {\n          this._onResolveSuggestions(input);\n        } else {\n          this.setState({\n            isMostRecentlyUsedVisible: false,\n            suggestionsVisible: true,\n          });\n        }\n      }\n    }\n  };\n}\n\nexport class BasePickerListBelow<T, P extends IBasePickerProps<T>> extends BasePicker<T, P> {\n  public render(): JSX.Element {\n    const { suggestedDisplayValue, isFocused } = this.state;\n    const { className, inputProps, disabled, selectionAriaLabel, selectionRole = 'list', theme, styles } = this.props;\n\n    const suggestionsVisible = !!this.state.suggestionsVisible;\n\n    const suggestionsAvailable: string | undefined = suggestionsVisible ? this._ariaMap.suggestionList : undefined;\n    // TODO\n    // Clean this up by leaving only the first part after removing support for SASS.\n    // Currently we can not remove the SASS styles from BasePicker class because it\n    // might be used by consumers who created custom pickers from extending from\n    // this base class and have not used the new 'styles' prop.\n    // We check for 'styles' prop which is going to be injected by the 'styled' HOC\n    // for every other already existing picker variant (PeoplePicker, TagPicker)\n    // so that we can use the CSS-in-JS styles. If the check fails (ex: custom picker),\n    // then we just use the old SASS styles instead.\n    const classNames: Partial<IProcessedStyleSet<IBasePickerStyles>> = styles\n      ? getClassNames(styles, {\n          theme,\n          className,\n          isFocused,\n          inputClassName: inputProps && inputProps.className,\n        })\n      : {\n          root: css('ms-BasePicker', className ? className : ''),\n          text: css(\n            'ms-BasePicker-text',\n            legacyStyles.pickerText,\n            this.state.isFocused && legacyStyles.inputFocused,\n            disabled && legacyStyles.inputDisabled,\n          ),\n          itemsWrapper: legacyStyles.pickerItems,\n          input: css('ms-BasePicker-input', legacyStyles.pickerInput, inputProps && inputProps.className),\n          screenReaderText: legacyStyles.screenReaderOnly,\n        };\n\n    const comboLabel = this.props['aria-label'] || inputProps?.['aria-label'];\n\n    return (\n      <div ref={this.root} onBlur={this.onBlur} onFocus={this.onFocus}>\n        <div className={classNames.root} onKeyDown={this.onKeyDown}>\n          {this.renderCustomAlert(classNames.screenReaderText)}\n          <div className={classNames.text} aria-owns={suggestionsAvailable}>\n            <Autofill\n              {...(inputProps as any)}\n              className={classNames.input}\n              componentRef={this.input}\n              onFocus={this.onInputFocus}\n              onBlur={this.onInputBlur}\n              onClick={this.onClick}\n              onInputValueChange={this.onInputChange}\n              suggestedDisplayValue={suggestedDisplayValue}\n              aria-activedescendant={suggestionsVisible ? this.getActiveDescendant() : undefined}\n              aria-controls={suggestionsAvailable}\n              aria-expanded={suggestionsVisible}\n              aria-haspopup=\"listbox\"\n              aria-label={comboLabel}\n              role=\"combobox\"\n              id={inputProps?.id ? inputProps.id : this._ariaMap.combobox}\n              disabled={disabled}\n              onInputChange={this.props.onInputChange}\n            />\n          </div>\n        </div>\n        {this.renderSuggestions()}\n        <SelectionZone selection={this.selection} selectionMode={SelectionMode.single}>\n          <div\n            id={this._ariaMap.selectedItems}\n            className=\"ms-BasePicker-selectedItems\" // just a className hook without any styles applied to it.\n            role={selectionRole}\n            aria-label={selectionAriaLabel || comboLabel}\n          >\n            {this.renderItems()}\n          </div>\n        </SelectionZone>\n      </div>\n    );\n  }\n\n  protected onBackspace(ev: React.KeyboardEvent<HTMLElement>) {\n    // override the existing backspace method to not do anything because the list items appear below.\n  }\n}\n"]},"metadata":{},"sourceType":"module"}