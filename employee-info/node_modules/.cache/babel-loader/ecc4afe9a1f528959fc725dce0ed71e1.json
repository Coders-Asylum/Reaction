{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, allowScrollOnElement, allowOverscrollOnElement, getPropsWithDefaults, KeyCodes, elementContains, EventGroup } from '../../Utilities';\nimport { FocusTrapZone } from '../../FocusTrapZone';\nimport { animationDuration } from './Modal.styles';\nimport { Overlay } from '../../Overlay';\nimport { Layer } from '../../Layer';\nimport { Popup } from '../../Popup';\nimport { ResponsiveMode, useResponsiveMode } from '../../ResponsiveMode';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { Icon } from '../../Icon';\nimport { DraggableZone } from '../../utilities/DraggableZone/index';\nimport { useWindow } from '@fluentui/react-window-provider';\nimport { useBoolean, useMergedRefs, useWarnings, useConst, useSetTimeout, useId, useUnmount } from '@fluentui/react-hooks';\nvar ZERO = {\n  x: 0,\n  y: 0\n};\nvar DEFAULT_PROPS = {\n  isOpen: false,\n  isDarkOverlay: true,\n  className: '',\n  containerClassName: '',\n  enableAriaHiddenSiblings: true\n};\nvar getClassNames = classNamesFunction();\n\nvar getMoveDelta = function getMoveDelta(ev) {\n  var delta = 10;\n\n  if (ev.shiftKey) {\n    if (!ev.ctrlKey) {\n      delta = 50;\n    }\n  } else if (ev.ctrlKey) {\n    delta = 1;\n  }\n\n  return delta;\n};\n\nvar useComponentRef = function useComponentRef(props, focusTrapZone) {\n  React.useImperativeHandle(props.componentRef, function () {\n    return {\n      focus: function focus() {\n        if (focusTrapZone.current) {\n          focusTrapZone.current.focus();\n        }\n      }\n    };\n  }, [focusTrapZone]);\n};\n\nexport var ModalBase = React.forwardRef(function (propsWithoutDefaults, ref) {\n  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n  var allowTouchBodyScroll = props.allowTouchBodyScroll,\n      className = props.className,\n      children = props.children,\n      containerClassName = props.containerClassName,\n      scrollableContentClassName = props.scrollableContentClassName,\n      elementToFocusOnDismiss = props.elementToFocusOnDismiss,\n      firstFocusableSelector = props.firstFocusableSelector,\n      forceFocusInsideTrap = props.forceFocusInsideTrap,\n      ignoreExternalFocusing = props.ignoreExternalFocusing,\n      isBlocking = props.isBlocking,\n      isAlert = props.isAlert,\n      isClickableOutsideFocusTrap = props.isClickableOutsideFocusTrap,\n      isDarkOverlay = props.isDarkOverlay,\n      onDismiss = props.onDismiss,\n      layerProps = props.layerProps,\n      overlay = props.overlay,\n      isOpen = props.isOpen,\n      titleAriaId = props.titleAriaId,\n      styles = props.styles,\n      subtitleAriaId = props.subtitleAriaId,\n      theme = props.theme,\n      topOffsetFixed = props.topOffsetFixed,\n      responsiveMode = props.responsiveMode,\n      // eslint-disable-next-line deprecation/deprecation\n  onLayerDidMount = props.onLayerDidMount,\n      isModeless = props.isModeless,\n      dragOptions = props.dragOptions,\n      onDismissed = props.onDismissed,\n      // eslint-disable-next-line deprecation/deprecation\n  enableAriaHiddenSiblings = props.enableAriaHiddenSiblings;\n  var rootRef = React.useRef(null);\n  var focusTrapZone = React.useRef(null);\n  var focusTrapZoneElm = React.useRef(null);\n  var mergedRef = useMergedRefs(rootRef, ref);\n  var modalResponsiveMode = useResponsiveMode(mergedRef);\n  var focusTrapZoneId = useId('ModalFocusTrapZone');\n  var win = useWindow();\n\n  var _a = useSetTimeout(),\n      setTimeout = _a.setTimeout,\n      clearTimeout = _a.clearTimeout;\n\n  var _b = React.useState(isOpen),\n      isModalOpen = _b[0],\n      setIsModalOpen = _b[1];\n\n  var _c = React.useState(isOpen),\n      isVisible = _c[0],\n      setIsVisible = _c[1];\n\n  var _d = React.useState(ZERO),\n      coordinates = _d[0],\n      setCoordinates = _d[1];\n\n  var _e = React.useState(),\n      modalRectangleTop = _e[0],\n      setModalRectangleTop = _e[1];\n\n  var _f = useBoolean(false),\n      isModalMenuOpen = _f[0],\n      _g = _f[1],\n      toggleModalMenuOpen = _g.toggle,\n      setModalMenuClose = _g.setFalse;\n\n  var internalState = useConst(function () {\n    return {\n      onModalCloseTimer: 0,\n      allowTouchBodyScroll: allowTouchBodyScroll,\n      scrollableContent: null,\n      lastSetCoordinates: ZERO,\n      events: new EventGroup({})\n    };\n  });\n  var keepInBounds = (dragOptions || {}).keepInBounds;\n  var isAlertRole = isAlert !== null && isAlert !== void 0 ? isAlert : isBlocking && !isModeless;\n  var layerClassName = layerProps === undefined ? '' : layerProps.className;\n  var classNames = getClassNames(styles, {\n    theme: theme,\n    className: className,\n    containerClassName: containerClassName,\n    scrollableContentClassName: scrollableContentClassName,\n    isOpen: isOpen,\n    isVisible: isVisible,\n    hasBeenOpened: internalState.hasBeenOpened,\n    modalRectangleTop: modalRectangleTop,\n    topOffsetFixed: topOffsetFixed,\n    isModeless: isModeless,\n    layerClassName: layerClassName,\n    windowInnerHeight: win === null || win === void 0 ? void 0 : win.innerHeight,\n    isDefaultDragHandle: dragOptions && !dragOptions.dragHandleSelector\n  });\n\n  var mergedLayerProps = __assign(__assign({\n    eventBubblingEnabled: false\n  }, layerProps), {\n    onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount,\n    insertFirst: isModeless,\n    className: classNames.layer\n  }); // Allow the user to scroll within the modal but not on the body\n\n\n  var allowScrollOnModal = React.useCallback(function (elt) {\n    if (elt) {\n      if (internalState.allowTouchBodyScroll) {\n        allowOverscrollOnElement(elt, internalState.events);\n      } else {\n        allowScrollOnElement(elt, internalState.events);\n      }\n    } else {\n      internalState.events.off(internalState.scrollableContent);\n    }\n\n    internalState.scrollableContent = elt;\n  }, [internalState]);\n\n  var registerInitialModalPosition = function registerInitialModalPosition() {\n    var dialogMain = focusTrapZoneElm.current;\n    var modalRectangle = dialogMain === null || dialogMain === void 0 ? void 0 : dialogMain.getBoundingClientRect();\n\n    if (modalRectangle) {\n      if (topOffsetFixed) {\n        setModalRectangleTop(modalRectangle.top);\n      }\n\n      if (keepInBounds) {\n        // x/y are unavailable in IE, so use the equivalent left/top\n        internalState.minPosition = {\n          x: -modalRectangle.left,\n          y: -modalRectangle.top\n        };\n        internalState.maxPosition = {\n          x: modalRectangle.left,\n          y: modalRectangle.top\n        };\n      }\n    }\n  };\n  /**\n   * Clamps an axis to a specified min and max position.\n   *\n   * @param axis A string that represents the axis (x/y).\n   * @param position The position on the axis.\n   */\n\n\n  var getClampedAxis = React.useCallback(function (axis, position) {\n    var minPosition = internalState.minPosition,\n        maxPosition = internalState.maxPosition;\n\n    if (keepInBounds && minPosition && maxPosition) {\n      position = Math.max(minPosition[axis], position);\n      position = Math.min(maxPosition[axis], position);\n    }\n\n    return position;\n  }, [keepInBounds, internalState]);\n\n  var handleModalClose = function handleModalClose() {\n    var _a;\n\n    internalState.lastSetCoordinates = ZERO;\n    setModalMenuClose();\n    internalState.isInKeyboardMoveMode = false;\n    setIsModalOpen(false);\n    setCoordinates(ZERO);\n    (_a = internalState.disposeOnKeyUp) === null || _a === void 0 ? void 0 : _a.call(internalState);\n    onDismissed === null || onDismissed === void 0 ? void 0 : onDismissed();\n  };\n\n  var handleDragStart = React.useCallback(function () {\n    setModalMenuClose();\n    internalState.isInKeyboardMoveMode = false;\n  }, [internalState, setModalMenuClose]);\n  var handleDrag = React.useCallback(function (ev, dragData) {\n    setCoordinates(function (prevValue) {\n      return {\n        x: getClampedAxis('x', prevValue.x + dragData.delta.x),\n        y: getClampedAxis('y', prevValue.y + dragData.delta.y)\n      };\n    });\n  }, [getClampedAxis]);\n  var handleDragStop = React.useCallback(function () {\n    if (focusTrapZone.current) {\n      focusTrapZone.current.focus();\n    }\n  }, []);\n\n  var handleEnterKeyboardMoveMode = function handleEnterKeyboardMoveMode() {\n    // We need a global handleKeyDown event when we are in the move mode so that we can\n    // handle the key presses and the components inside the modal do not get the events\n    var handleKeyDown = function handleKeyDown(ev) {\n      // eslint-disable-next-line deprecation/deprecation\n      if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {\n        // CTRL + ALT + SPACE is handled during keyUp\n        ev.preventDefault();\n        ev.stopPropagation();\n        return;\n      } // eslint-disable-next-line deprecation/deprecation\n\n\n      var newLocal = ev.altKey || ev.keyCode === KeyCodes.escape;\n\n      if (isModalMenuOpen && newLocal) {\n        setModalMenuClose();\n      } // eslint-disable-next-line deprecation/deprecation\n\n\n      if (internalState.isInKeyboardMoveMode && (ev.keyCode === KeyCodes.escape || ev.keyCode === KeyCodes.enter)) {\n        internalState.isInKeyboardMoveMode = false;\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n\n      if (internalState.isInKeyboardMoveMode) {\n        var handledEvent = true;\n        var delta_1 = getMoveDelta(ev); // eslint-disable-next-line deprecation/deprecation\n\n        switch (ev.keyCode) {\n          /* eslint-disable no-fallthrough */\n          case KeyCodes.escape:\n            setCoordinates(internalState.lastSetCoordinates);\n\n          case KeyCodes.enter:\n            {\n              // TODO: determine if fallthrough was intentional\n\n              /* eslint-enable no-fallthrough */\n              internalState.lastSetCoordinates = ZERO; // setIsInKeyboardMoveMode(false);\n\n              break;\n            }\n\n          case KeyCodes.up:\n            {\n              setCoordinates(function (prevValue) {\n                return {\n                  x: prevValue.x,\n                  y: getClampedAxis('y', prevValue.y - delta_1)\n                };\n              });\n              break;\n            }\n\n          case KeyCodes.down:\n            {\n              setCoordinates(function (prevValue) {\n                return {\n                  x: prevValue.x,\n                  y: getClampedAxis('y', prevValue.y + delta_1)\n                };\n              });\n              break;\n            }\n\n          case KeyCodes.left:\n            {\n              setCoordinates(function (prevValue) {\n                return {\n                  x: getClampedAxis('x', prevValue.x - delta_1),\n                  y: prevValue.y\n                };\n              });\n              break;\n            }\n\n          case KeyCodes.right:\n            {\n              setCoordinates(function (prevValue) {\n                return {\n                  x: getClampedAxis('x', prevValue.x + delta_1),\n                  y: prevValue.y\n                };\n              });\n              break;\n            }\n\n          default:\n            {\n              handledEvent = false;\n            }\n        }\n\n        if (handledEvent) {\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n\n    internalState.lastSetCoordinates = coordinates;\n    setModalMenuClose();\n    internalState.isInKeyboardMoveMode = true;\n    internalState.events.on(win, 'keydown', handleKeyDown, true\n    /* useCapture */\n    );\n\n    internalState.disposeOnKeyDown = function () {\n      internalState.events.off(win, 'keydown', handleKeyDown, true\n      /* useCapture */\n      );\n      internalState.disposeOnKeyDown = undefined;\n    };\n  };\n\n  var handleExitKeyboardMoveMode = function handleExitKeyboardMoveMode() {\n    var _a;\n\n    internalState.lastSetCoordinates = ZERO;\n    internalState.isInKeyboardMoveMode = false;\n    (_a = internalState.disposeOnKeyDown) === null || _a === void 0 ? void 0 : _a.call(internalState);\n  };\n\n  var registerForKeyUp = function registerForKeyUp() {\n    var handleKeyUp = function handleKeyUp(ev) {\n      // Needs to handle the CTRL + ALT + SPACE key during keyup due to FireFox bug:\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n      // eslint-disable-next-line deprecation/deprecation\n      if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {\n        if (elementContains(internalState.scrollableContent, ev.target)) {\n          toggleModalMenuOpen();\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n\n    if (!internalState.disposeOnKeyUp) {\n      internalState.events.on(win, 'keyup', handleKeyUp, true\n      /* useCapture */\n      );\n\n      internalState.disposeOnKeyUp = function () {\n        internalState.events.off(win, 'keyup', handleKeyUp, true\n        /* useCapture */\n        );\n        internalState.disposeOnKeyUp = undefined;\n      };\n    }\n  };\n\n  React.useEffect(function () {\n    clearTimeout(internalState.onModalCloseTimer); // Opening the dialog\n\n    if (isOpen) {\n      // This must be done after the modal content has rendered\n      requestAnimationFrame(function () {\n        return setTimeout(registerInitialModalPosition, 0);\n      });\n      setIsModalOpen(true); // Add a keyUp handler for all key up events once the dialog is open.\n\n      if (dragOptions) {\n        registerForKeyUp();\n      }\n\n      internalState.hasBeenOpened = true;\n      setIsVisible(true);\n    } // Closing the dialog\n\n\n    if (!isOpen && isModalOpen) {\n      internalState.onModalCloseTimer = setTimeout(handleModalClose, parseFloat(animationDuration) * 1000);\n      setIsVisible(false);\n    } // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if isModalOpen or isOpen mutates.\n\n  }, [isModalOpen, isOpen]);\n  useUnmount(function () {\n    internalState.events.dispose();\n  });\n  useComponentRef(props, focusTrapZone);\n  useDebugWarnings(props);\n  var modalContent = React.createElement(FocusTrapZone, {\n    id: focusTrapZoneId,\n    ref: focusTrapZoneElm,\n    componentRef: focusTrapZone,\n    className: classNames.main,\n    elementToFocusOnDismiss: elementToFocusOnDismiss,\n    isClickableOutsideFocusTrap: isModeless || isClickableOutsideFocusTrap || !isBlocking,\n    ignoreExternalFocusing: ignoreExternalFocusing,\n    forceFocusInsideTrap: forceFocusInsideTrap && !isModeless,\n    firstFocusableSelector: firstFocusableSelector,\n    focusPreviouslyFocusedInnerElement: true,\n    onBlur: internalState.isInKeyboardMoveMode ? handleExitKeyboardMoveMode : undefined\n  }, dragOptions && internalState.isInKeyboardMoveMode && React.createElement(\"div\", {\n    className: classNames.keyboardMoveIconContainer\n  }, dragOptions.keyboardMoveIconProps ? React.createElement(Icon, __assign({}, dragOptions.keyboardMoveIconProps)) : React.createElement(Icon, {\n    iconName: \"move\",\n    className: classNames.keyboardMoveIcon\n  })), React.createElement(\"div\", {\n    ref: allowScrollOnModal,\n    className: classNames.scrollableContent,\n    \"data-is-scrollable\": true\n  }, dragOptions && isModalMenuOpen && React.createElement(dragOptions.menu, {\n    items: [{\n      key: 'move',\n      text: dragOptions.moveMenuItemText,\n      onClick: handleEnterKeyboardMoveMode\n    }, {\n      key: 'close',\n      text: dragOptions.closeMenuItemText,\n      onClick: handleModalClose\n    }],\n    onDismiss: setModalMenuClose,\n    alignTargetEdge: true,\n    coverTarget: true,\n    directionalHint: DirectionalHint.topLeftEdge,\n    directionalHintFixed: true,\n    shouldFocusOnMount: true,\n    target: internalState.scrollableContent\n  }), children));\n  return isModalOpen && modalResponsiveMode >= (responsiveMode || ResponsiveMode.small) && React.createElement(Layer, __assign({\n    ref: mergedRef\n  }, mergedLayerProps), React.createElement(Popup, {\n    role: isAlertRole ? 'alertdialog' : 'dialog',\n    ariaLabelledBy: titleAriaId,\n    ariaDescribedBy: subtitleAriaId,\n    onDismiss: onDismiss,\n    shouldRestoreFocus: !ignoreExternalFocusing,\n    // Modeless modals shouldn't hide siblings.\n    // Popup will automatically handle this based on the aria-modal setting.\n    enableAriaHiddenSiblings: enableAriaHiddenSiblings,\n    \"aria-modal\": !isModeless\n  }, React.createElement(\"div\", {\n    className: classNames.root,\n    role: !isModeless ? 'document' : undefined\n  }, !isModeless && React.createElement(Overlay, __assign({\n    \"aria-hidden\": true,\n    isDarkThemed: isDarkOverlay,\n    onClick: isBlocking ? undefined : onDismiss,\n    allowTouchBodyScroll: allowTouchBodyScroll\n  }, overlay)), dragOptions ? React.createElement(DraggableZone, {\n    handleSelector: dragOptions.dragHandleSelector || \"#\" + focusTrapZoneId,\n    preventDragSelector: \"button\",\n    onStart: handleDragStart,\n    onDragChange: handleDrag,\n    onStop: handleDragStop,\n    position: coordinates\n  }, modalContent) : modalContent))) || null;\n});\nModalBase.displayName = 'Modal';\n\nfunction useDebugWarnings(props) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: 'Modal',\n      props: props,\n      deprecations: {\n        onLayerDidMount: 'layerProps.onLayerDidMount'\n      }\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["React","classNamesFunction","allowScrollOnElement","allowOverscrollOnElement","getPropsWithDefaults","KeyCodes","elementContains","EventGroup","FocusTrapZone","animationDuration","Overlay","Layer","Popup","ResponsiveMode","useResponsiveMode","DirectionalHint","Icon","DraggableZone","useWindow","useBoolean","useMergedRefs","useWarnings","useConst","useSetTimeout","useId","useUnmount","ZERO","x","y","DEFAULT_PROPS","isOpen","isDarkOverlay","className","containerClassName","enableAriaHiddenSiblings","getClassNames","getMoveDelta","ev","delta","shiftKey","ctrlKey","useComponentRef","props","focusTrapZone","useImperativeHandle","componentRef","focus","current","ModalBase","forwardRef","propsWithoutDefaults","ref","children","scrollableContentClassName","elementToFocusOnDismiss","firstFocusableSelector","forceFocusInsideTrap","ignoreExternalFocusing","isBlocking","isAlert","isClickableOutsideFocusTrap","onDismiss","layerProps","overlay","titleAriaId","styles","subtitleAriaId","theme","topOffsetFixed","responsiveMode","onLayerDidMount","isModeless","dragOptions","onDismissed","rootRef","useRef","focusTrapZoneElm","mergedRef","modalResponsiveMode","focusTrapZoneId","win","setTimeout","clearTimeout","useState","isModalOpen","setIsModalOpen","isVisible","setIsVisible","coordinates","setCoordinates","modalRectangleTop","setModalRectangleTop","isModalMenuOpen","_g","toggleModalMenuOpen","setModalMenuClose","internalState","onModalCloseTimer","allowTouchBodyScroll","scrollableContent","lastSetCoordinates","events","keepInBounds","isAlertRole","layerClassName","undefined","classNames","hasBeenOpened","windowInnerHeight","innerHeight","isDefaultDragHandle","dragHandleSelector","mergedLayerProps","eventBubblingEnabled","insertFirst","layer","allowScrollOnModal","useCallback","elt","off","registerInitialModalPosition","dialogMain","modalRectangle","getBoundingClientRect","top","minPosition","left","maxPosition","getClampedAxis","axis","position","Math","max","min","handleModalClose","isInKeyboardMoveMode","disposeOnKeyUp","_a","handleDragStart","handleDrag","dragData","prevValue","handleDragStop","handleEnterKeyboardMoveMode","handleKeyDown","altKey","keyCode","space","preventDefault","stopPropagation","newLocal","escape","enter","handledEvent","delta_1","up","down","right","on","disposeOnKeyDown","handleExitKeyboardMoveMode","registerForKeyUp","handleKeyUp","target","useEffect","requestAnimationFrame","parseFloat","dispose","useDebugWarnings","modalContent","id","main","focusPreviouslyFocusedInnerElement","onBlur","keyboardMoveIconContainer","keyboardMoveIconProps","__assign","iconName","keyboardMoveIcon","menu","items","key","text","moveMenuItemText","onClick","closeMenuItemText","alignTargetEdge","coverTarget","directionalHint","topLeftEdge","directionalHintFixed","shouldFocusOnMount","small","role","ariaLabelledBy","ariaDescribedBy","shouldRestoreFocus","root","isDarkThemed","handleSelector","preventDragSelector","onStart","onDragChange","onStop","displayName","process","env","NODE_ENV","name","deprecations"],"sources":["/home/runner/work/Reaction/Reaction/employee-info/node_modules/@fluentui/react/lib/components/src/components/Modal/Modal.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  classNamesFunction,\n  allowScrollOnElement,\n  allowOverscrollOnElement,\n  getPropsWithDefaults,\n  KeyCodes,\n  elementContains,\n  EventGroup,\n} from '../../Utilities';\nimport { FocusTrapZone } from '../../FocusTrapZone';\nimport { animationDuration } from './Modal.styles';\nimport { Overlay } from '../../Overlay';\nimport { Layer } from '../../Layer';\nimport { Popup } from '../../Popup';\nimport { ResponsiveMode, useResponsiveMode } from '../../ResponsiveMode';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { Icon } from '../../Icon';\nimport { DraggableZone } from '../../utilities/DraggableZone/index';\nimport { useWindow } from '@fluentui/react-window-provider';\nimport {\n  useBoolean,\n  useMergedRefs,\n  useWarnings,\n  useConst,\n  useSetTimeout,\n  useId,\n  useUnmount,\n} from '@fluentui/react-hooks';\nimport type { IFocusTrapZone } from '../../FocusTrapZone';\nimport type { IDragOptions, IModalProps, IModalStyleProps, IModalStyles } from './Modal.types';\nimport type { ILayerProps } from '../../Layer';\nimport type { ICoordinates, IDragData } from '../../utilities/DraggableZone/index';\n\n// @TODO - need to change this to a panel whenever the breakpoint is under medium (verify the spec)\n\ninterface IModalInternalState {\n  onModalCloseTimer: number;\n  allowTouchBodyScroll?: boolean;\n  scrollableContent: HTMLDivElement | null;\n  lastSetCoordinates: ICoordinates;\n  /** Minimum clamped position, if dragging and clamping (`dragOptions.keepInBounds`) are enabled */\n  minPosition?: ICoordinates;\n  /** Maximum clamped position, if dragging and clamping (`dragOptions.keepInBounds`) are enabled */\n  maxPosition?: ICoordinates;\n  events: EventGroup;\n  /** Ensures we dispose the same keydown callback as was registered */\n  disposeOnKeyDown?: () => void;\n  /** Ensures we dispose the same keyup callback as was registered (also tracks whether keyup has been registered) */\n  disposeOnKeyUp?: () => void;\n  isInKeyboardMoveMode?: boolean;\n  hasBeenOpened?: boolean;\n}\n\nconst ZERO: ICoordinates = { x: 0, y: 0 };\n\nconst DEFAULT_PROPS: Partial<IModalProps> = {\n  isOpen: false,\n  isDarkOverlay: true,\n  className: '',\n  containerClassName: '',\n  enableAriaHiddenSiblings: true,\n};\n\nconst getClassNames = classNamesFunction<IModalStyleProps, IModalStyles>();\n\nconst getMoveDelta = (ev: React.KeyboardEvent<HTMLElement>): number => {\n  let delta = 10;\n  if (ev.shiftKey) {\n    if (!ev.ctrlKey) {\n      delta = 50;\n    }\n  } else if (ev.ctrlKey) {\n    delta = 1;\n  }\n\n  return delta;\n};\n\nconst useComponentRef = (props: IModalProps, focusTrapZone: React.RefObject<IFocusTrapZone>) => {\n  React.useImperativeHandle(\n    props.componentRef,\n    () => ({\n      focus() {\n        if (focusTrapZone.current) {\n          focusTrapZone.current.focus();\n        }\n      },\n    }),\n    [focusTrapZone],\n  );\n};\n\nexport const ModalBase: React.FunctionComponent<IModalProps> = React.forwardRef<HTMLDivElement, IModalProps>(\n  (propsWithoutDefaults, ref) => {\n    const props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n    const {\n      allowTouchBodyScroll,\n      className,\n      children,\n      containerClassName,\n      scrollableContentClassName,\n      elementToFocusOnDismiss,\n      firstFocusableSelector,\n      forceFocusInsideTrap,\n      ignoreExternalFocusing,\n      isBlocking,\n      isAlert,\n      isClickableOutsideFocusTrap,\n      isDarkOverlay,\n      onDismiss,\n      layerProps,\n      overlay,\n      isOpen,\n      titleAriaId,\n      styles,\n      subtitleAriaId,\n      theme,\n      topOffsetFixed,\n      responsiveMode,\n      // eslint-disable-next-line deprecation/deprecation\n      onLayerDidMount,\n      isModeless,\n      dragOptions,\n      onDismissed,\n      // eslint-disable-next-line deprecation/deprecation\n      enableAriaHiddenSiblings,\n    } = props;\n\n    const rootRef = React.useRef<HTMLDivElement>(null);\n    const focusTrapZone = React.useRef<IFocusTrapZone>(null);\n    const focusTrapZoneElm = React.useRef<HTMLDivElement>(null);\n    const mergedRef = useMergedRefs(rootRef, ref);\n\n    const modalResponsiveMode = useResponsiveMode(mergedRef);\n\n    const focusTrapZoneId = useId('ModalFocusTrapZone');\n\n    const win = useWindow();\n\n    const { setTimeout, clearTimeout } = useSetTimeout();\n\n    const [isModalOpen, setIsModalOpen] = React.useState(isOpen);\n    const [isVisible, setIsVisible] = React.useState(isOpen);\n    const [coordinates, setCoordinates] = React.useState<ICoordinates>(ZERO);\n    const [modalRectangleTop, setModalRectangleTop] = React.useState<number | undefined>();\n\n    const [isModalMenuOpen, { toggle: toggleModalMenuOpen, setFalse: setModalMenuClose }] = useBoolean(false);\n\n    const internalState = useConst<IModalInternalState>(() => ({\n      onModalCloseTimer: 0,\n      allowTouchBodyScroll,\n      scrollableContent: null,\n      lastSetCoordinates: ZERO,\n      events: new EventGroup({}),\n    }));\n\n    const { keepInBounds } = dragOptions || ({} as IDragOptions);\n    const isAlertRole = isAlert ?? (isBlocking && !isModeless);\n\n    const layerClassName = layerProps === undefined ? '' : layerProps.className;\n    const classNames = getClassNames(styles, {\n      theme: theme!,\n      className,\n      containerClassName,\n      scrollableContentClassName,\n      isOpen,\n      isVisible,\n      hasBeenOpened: internalState.hasBeenOpened,\n      modalRectangleTop,\n      topOffsetFixed,\n      isModeless,\n      layerClassName,\n      windowInnerHeight: win?.innerHeight,\n      isDefaultDragHandle: dragOptions && !dragOptions.dragHandleSelector,\n    });\n\n    const mergedLayerProps: ILayerProps = {\n      eventBubblingEnabled: false,\n      ...layerProps,\n      onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount,\n      insertFirst: isModeless,\n      className: classNames.layer,\n    };\n\n    // Allow the user to scroll within the modal but not on the body\n    const allowScrollOnModal = React.useCallback(\n      (elt: HTMLDivElement | null): void => {\n        if (elt) {\n          if (internalState.allowTouchBodyScroll) {\n            allowOverscrollOnElement(elt, internalState.events);\n          } else {\n            allowScrollOnElement(elt, internalState.events);\n          }\n        } else {\n          internalState.events.off(internalState.scrollableContent);\n        }\n        internalState.scrollableContent = elt;\n      },\n      [internalState],\n    );\n\n    const registerInitialModalPosition = (): void => {\n      const dialogMain = focusTrapZoneElm.current;\n      const modalRectangle = dialogMain?.getBoundingClientRect();\n\n      if (modalRectangle) {\n        if (topOffsetFixed) {\n          setModalRectangleTop(modalRectangle.top);\n        }\n\n        if (keepInBounds) {\n          // x/y are unavailable in IE, so use the equivalent left/top\n          internalState.minPosition = { x: -modalRectangle.left, y: -modalRectangle.top };\n          internalState.maxPosition = { x: modalRectangle.left, y: modalRectangle.top };\n        }\n      }\n    };\n\n    /**\n     * Clamps an axis to a specified min and max position.\n     *\n     * @param axis A string that represents the axis (x/y).\n     * @param position The position on the axis.\n     */\n    const getClampedAxis = React.useCallback(\n      (axis: keyof ICoordinates, position: number) => {\n        const { minPosition, maxPosition } = internalState;\n        if (keepInBounds && minPosition && maxPosition) {\n          position = Math.max(minPosition[axis], position);\n          position = Math.min(maxPosition[axis], position);\n        }\n        return position;\n      },\n      [keepInBounds, internalState],\n    );\n\n    const handleModalClose = (): void => {\n      internalState.lastSetCoordinates = ZERO;\n\n      setModalMenuClose();\n      internalState.isInKeyboardMoveMode = false;\n      setIsModalOpen(false);\n      setCoordinates(ZERO);\n\n      internalState.disposeOnKeyUp?.();\n\n      onDismissed?.();\n    };\n\n    const handleDragStart = React.useCallback((): void => {\n      setModalMenuClose();\n      internalState.isInKeyboardMoveMode = false;\n    }, [internalState, setModalMenuClose]);\n\n    const handleDrag = React.useCallback(\n      (ev: React.MouseEvent<HTMLElement> & React.TouchEvent<HTMLElement>, dragData: IDragData): void => {\n        setCoordinates(prevValue => ({\n          x: getClampedAxis('x', prevValue.x + dragData.delta.x),\n          y: getClampedAxis('y', prevValue.y + dragData.delta.y),\n        }));\n      },\n      [getClampedAxis],\n    );\n\n    const handleDragStop = React.useCallback((): void => {\n      if (focusTrapZone.current) {\n        focusTrapZone.current.focus();\n      }\n    }, []);\n\n    const handleEnterKeyboardMoveMode = () => {\n      // We need a global handleKeyDown event when we are in the move mode so that we can\n      // handle the key presses and the components inside the modal do not get the events\n      const handleKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n        // eslint-disable-next-line deprecation/deprecation\n        if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {\n          // CTRL + ALT + SPACE is handled during keyUp\n          ev.preventDefault();\n          ev.stopPropagation();\n          return;\n        }\n\n        // eslint-disable-next-line deprecation/deprecation\n        const newLocal = ev.altKey || ev.keyCode === KeyCodes.escape;\n        if (isModalMenuOpen && newLocal) {\n          setModalMenuClose();\n        }\n\n        // eslint-disable-next-line deprecation/deprecation\n        if (internalState.isInKeyboardMoveMode && (ev.keyCode === KeyCodes.escape || ev.keyCode === KeyCodes.enter)) {\n          internalState.isInKeyboardMoveMode = false;\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n\n        if (internalState.isInKeyboardMoveMode) {\n          let handledEvent = true;\n          const delta = getMoveDelta(ev);\n\n          // eslint-disable-next-line deprecation/deprecation\n          switch (ev.keyCode) {\n            /* eslint-disable no-fallthrough */\n            case KeyCodes.escape:\n              setCoordinates(internalState.lastSetCoordinates);\n            case KeyCodes.enter: {\n              // TODO: determine if fallthrough was intentional\n              /* eslint-enable no-fallthrough */\n              internalState.lastSetCoordinates = ZERO;\n              // setIsInKeyboardMoveMode(false);\n              break;\n            }\n            case KeyCodes.up: {\n              setCoordinates(prevValue => ({ x: prevValue.x, y: getClampedAxis('y', prevValue.y - delta) }));\n              break;\n            }\n            case KeyCodes.down: {\n              setCoordinates(prevValue => ({ x: prevValue.x, y: getClampedAxis('y', prevValue.y + delta) }));\n              break;\n            }\n            case KeyCodes.left: {\n              setCoordinates(prevValue => ({ x: getClampedAxis('x', prevValue.x - delta), y: prevValue.y }));\n              break;\n            }\n            case KeyCodes.right: {\n              setCoordinates(prevValue => ({ x: getClampedAxis('x', prevValue.x + delta), y: prevValue.y }));\n              break;\n            }\n            default: {\n              handledEvent = false;\n            }\n          }\n          if (handledEvent) {\n            ev.preventDefault();\n            ev.stopPropagation();\n          }\n        }\n      };\n\n      internalState.lastSetCoordinates = coordinates;\n      setModalMenuClose();\n      internalState.isInKeyboardMoveMode = true;\n\n      internalState.events.on(win, 'keydown', handleKeyDown, true /* useCapture */);\n      internalState.disposeOnKeyDown = () => {\n        internalState.events.off(win, 'keydown', handleKeyDown, true /* useCapture */);\n        internalState.disposeOnKeyDown = undefined;\n      };\n    };\n\n    const handleExitKeyboardMoveMode = () => {\n      internalState.lastSetCoordinates = ZERO;\n      internalState.isInKeyboardMoveMode = false;\n      internalState.disposeOnKeyDown?.();\n    };\n\n    const registerForKeyUp = (): void => {\n      const handleKeyUp = (ev: React.KeyboardEvent<HTMLElement>): void => {\n        // Needs to handle the CTRL + ALT + SPACE key during keyup due to FireFox bug:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n        // eslint-disable-next-line deprecation/deprecation\n        if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {\n          if (elementContains(internalState.scrollableContent, ev.target as HTMLElement)) {\n            toggleModalMenuOpen();\n            ev.preventDefault();\n            ev.stopPropagation();\n          }\n        }\n      };\n\n      if (!internalState.disposeOnKeyUp) {\n        internalState.events.on(win, 'keyup', handleKeyUp, true /* useCapture */);\n        internalState.disposeOnKeyUp = () => {\n          internalState.events.off(win, 'keyup', handleKeyUp, true /* useCapture */);\n          internalState.disposeOnKeyUp = undefined;\n        };\n      }\n    };\n\n    React.useEffect(() => {\n      clearTimeout(internalState.onModalCloseTimer);\n      // Opening the dialog\n      if (isOpen) {\n        // This must be done after the modal content has rendered\n        requestAnimationFrame(() => setTimeout(registerInitialModalPosition, 0));\n\n        setIsModalOpen(true);\n\n        // Add a keyUp handler for all key up events once the dialog is open.\n        if (dragOptions) {\n          registerForKeyUp();\n        }\n\n        internalState.hasBeenOpened = true;\n        setIsVisible(true);\n      }\n\n      // Closing the dialog\n      if (!isOpen && isModalOpen) {\n        internalState.onModalCloseTimer = setTimeout(handleModalClose, parseFloat(animationDuration) * 1000);\n        setIsVisible(false);\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if isModalOpen or isOpen mutates.\n    }, [isModalOpen, isOpen]);\n\n    useUnmount(() => {\n      internalState.events.dispose();\n    });\n\n    useComponentRef(props, focusTrapZone);\n    useDebugWarnings(props);\n\n    const modalContent = (\n      <FocusTrapZone\n        id={focusTrapZoneId}\n        ref={focusTrapZoneElm}\n        componentRef={focusTrapZone}\n        className={classNames.main}\n        elementToFocusOnDismiss={elementToFocusOnDismiss}\n        isClickableOutsideFocusTrap={isModeless || isClickableOutsideFocusTrap || !isBlocking}\n        ignoreExternalFocusing={ignoreExternalFocusing}\n        forceFocusInsideTrap={forceFocusInsideTrap && !isModeless}\n        firstFocusableSelector={firstFocusableSelector}\n        focusPreviouslyFocusedInnerElement\n        onBlur={internalState.isInKeyboardMoveMode ? handleExitKeyboardMoveMode : undefined}\n        // enableAriaHiddenSiblings is handled by the Popup\n      >\n        {dragOptions && internalState.isInKeyboardMoveMode && (\n          <div className={classNames.keyboardMoveIconContainer}>\n            {dragOptions.keyboardMoveIconProps ? (\n              <Icon {...dragOptions.keyboardMoveIconProps} />\n            ) : (\n              <Icon iconName=\"move\" className={classNames.keyboardMoveIcon} />\n            )}\n          </div>\n        )}\n        <div ref={allowScrollOnModal} className={classNames.scrollableContent} data-is-scrollable>\n          {dragOptions && isModalMenuOpen && (\n            <dragOptions.menu\n              items={[\n                { key: 'move', text: dragOptions.moveMenuItemText, onClick: handleEnterKeyboardMoveMode },\n                { key: 'close', text: dragOptions.closeMenuItemText, onClick: handleModalClose },\n              ]}\n              onDismiss={setModalMenuClose}\n              alignTargetEdge\n              coverTarget\n              directionalHint={DirectionalHint.topLeftEdge}\n              directionalHintFixed\n              shouldFocusOnMount\n              target={internalState.scrollableContent}\n            />\n          )}\n          {children}\n        </div>\n      </FocusTrapZone>\n    );\n\n    return (\n      (isModalOpen && modalResponsiveMode! >= (responsiveMode || ResponsiveMode.small) && (\n        <Layer ref={mergedRef} {...mergedLayerProps}>\n          <Popup\n            role={isAlertRole ? 'alertdialog' : 'dialog'}\n            ariaLabelledBy={titleAriaId}\n            ariaDescribedBy={subtitleAriaId}\n            onDismiss={onDismiss}\n            shouldRestoreFocus={!ignoreExternalFocusing}\n            // Modeless modals shouldn't hide siblings.\n            // Popup will automatically handle this based on the aria-modal setting.\n            enableAriaHiddenSiblings={enableAriaHiddenSiblings}\n            aria-modal={!isModeless}\n          >\n            <div className={classNames.root} role={!isModeless ? 'document' : undefined}>\n              {!isModeless && (\n                <Overlay\n                  aria-hidden={true}\n                  isDarkThemed={isDarkOverlay}\n                  onClick={isBlocking ? undefined : onDismiss}\n                  allowTouchBodyScroll={allowTouchBodyScroll}\n                  {...overlay}\n                />\n              )}\n              {dragOptions ? (\n                <DraggableZone\n                  handleSelector={dragOptions.dragHandleSelector || `#${focusTrapZoneId}`}\n                  preventDragSelector=\"button\"\n                  onStart={handleDragStart}\n                  onDragChange={handleDrag}\n                  onStop={handleDragStop}\n                  position={coordinates}\n                >\n                  {modalContent}\n                </DraggableZone>\n              ) : (\n                modalContent\n              )}\n            </div>\n          </Popup>\n        </Layer>\n      )) ||\n      null\n    );\n  },\n);\nModalBase.displayName = 'Modal';\n\nfunction useDebugWarnings(props: IModalProps) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: 'Modal',\n      props,\n      deprecations: { onLayerDidMount: 'layerProps.onLayerDidMount' },\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}