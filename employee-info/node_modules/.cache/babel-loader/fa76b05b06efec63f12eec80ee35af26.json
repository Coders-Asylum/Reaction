{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { useId, useControllableValue, useConst, useSetTimeout } from '@fluentui/react-hooks';\nimport { KeyCodes, css, getRTL, getRTLSafeKeyCode, on, classNamesFunction, getNativeProps, divProperties } from '@fluentui/utilities';\nexport var ONKEYDOWN_TIMEOUT_DURATION = 1000;\nvar getClassNames = classNamesFunction();\n\nvar getSlotStyleFn = function getSlotStyleFn(sty) {\n  return function (value) {\n    var _a;\n\n    return _a = {}, _a[sty] = value + \"%\", _a;\n  };\n};\n\nvar getPercent = function getPercent(value, sliderMin, sliderMax) {\n  return sliderMax === sliderMin ? 0 : (value - sliderMin) / (sliderMax - sliderMin) * 100;\n};\n\nvar useComponentRef = function useComponentRef(props, thumb, value, range) {\n  React.useImperativeHandle(props.componentRef, function () {\n    return {\n      get value() {\n        return value;\n      },\n\n      get range() {\n        return range;\n      },\n\n      focus: function focus() {\n        if (thumb.current) {\n          thumb.current.focus();\n        }\n      }\n    };\n  }, [thumb, value, range]);\n};\n\nexport var useSlider = function useSlider(props, ref) {\n  var _a = props.step,\n      step = _a === void 0 ? 1 : _a,\n      className = props.className,\n      _b = props.disabled,\n      disabled = _b === void 0 ? false : _b,\n      label = props.label,\n      _c = props.max,\n      max = _c === void 0 ? 10 : _c,\n      _d = props.min,\n      min = _d === void 0 ? 0 : _d,\n      _e = props.showValue,\n      showValue = _e === void 0 ? true : _e,\n      _f = props.buttonProps,\n      buttonProps = _f === void 0 ? {} : _f,\n      _g = props.vertical,\n      vertical = _g === void 0 ? false : _g,\n      snapToStep = props.snapToStep,\n      valueFormat = props.valueFormat,\n      styles = props.styles,\n      theme = props.theme,\n      originFromZero = props.originFromZero,\n      ariaLabelledBy = props[\"aria-labelledby\"],\n      ariaLabel = props[\"aria-label\"],\n      ranged = props.ranged,\n      onChange = props.onChange,\n      onChanged = props.onChanged;\n  var disposables = React.useRef([]);\n\n  var _h = useSetTimeout(),\n      setTimeout = _h.setTimeout,\n      clearTimeout = _h.clearTimeout;\n\n  var sliderLine = React.useRef(null); // Casting here is necessary because useControllableValue expects the event for the change callback\n  // to extend React.SyntheticEvent, when in fact for Slider, the event could be either a React event\n  // or a native browser event depending on the context.\n\n  var _j = useControllableValue(props.value, props.defaultValue, function (ev, v) {\n    return onChange === null || onChange === void 0 ? void 0 : onChange(v, ranged ? [internalState.latestLowerValue, v] : undefined, ev);\n  }),\n      unclampedValue = _j[0],\n      setValue = _j[1];\n\n  var _k = useControllableValue(props.lowerValue, props.defaultLowerValue, function (ev, lv) {\n    return onChange === null || onChange === void 0 ? void 0 : onChange(internalState.latestValue, [lv, internalState.latestValue], ev);\n  }),\n      unclampedLowerValue = _k[0],\n      setLowerValue = _k[1]; // Ensure that value is always a number and is clamped by min/max.\n\n\n  var value = Math.max(min, Math.min(max, unclampedValue || 0));\n  var lowerValue = Math.max(min, Math.min(value, unclampedLowerValue || 0));\n  var internalState = useConst({\n    onKeyDownTimer: -1,\n    isAdjustingLowerValue: false,\n    latestValue: value,\n    latestLowerValue: lowerValue\n  }); // On each render, update this saved value used by callbacks. (This should be safe even if render\n  // is called multiple times, because an event handler or timeout callback will only run once.)\n\n  internalState.latestValue = value;\n  internalState.latestLowerValue = lowerValue;\n  var id = useId('Slider', props.id || (buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.id));\n  var classNames = getClassNames(styles, {\n    className: className,\n    disabled: disabled,\n    vertical: vertical,\n    showTransitions: !snapToStep && !internalState.isBetweenSteps,\n    showValue: showValue,\n    ranged: ranged,\n    theme: theme\n  });\n  var steps = (max - min) / step;\n\n  var clearOnKeyDownTimer = function clearOnKeyDownTimer() {\n    clearTimeout(internalState.onKeyDownTimer);\n    internalState.onKeyDownTimer = -1;\n  };\n\n  var setOnKeyDownTimer = function setOnKeyDownTimer(event) {\n    clearOnKeyDownTimer();\n\n    if (onChanged) {\n      internalState.onKeyDownTimer = setTimeout(function () {\n        onChanged(event, internalState.latestValue, ranged ? [internalState.latestLowerValue, internalState.latestValue] : undefined);\n      }, ONKEYDOWN_TIMEOUT_DURATION);\n    }\n  };\n\n  var getAriaValueText = function getAriaValueText(valueProps) {\n    var ariaValueText = props.ariaValueText;\n\n    if (valueProps !== undefined) {\n      return ariaValueText ? ariaValueText(valueProps) : valueProps.toString();\n    }\n\n    return undefined;\n  };\n  /**\n   * Update `value` or `lowerValue`, including clamping between min/max and rounding to\n   * appropriate precision.\n   * @param newValue - New current value of the slider, possibly rounded to a whole step.\n   * @param newUnroundedValue - Like `newValue` but without the rounding to a step. If this is\n   * provided and not equal to `newValue`, `internalState.isBetweenSteps` will be set, which\n   * may cause thumb movement animations to be disabled.\n   */\n\n\n  var updateValue = function updateValue(ev, newValue, newUnroundedValue) {\n    newValue = Math.min(max, Math.max(min, newValue));\n    newUnroundedValue = newUnroundedValue !== undefined ? Math.min(max, Math.max(min, newUnroundedValue)) : undefined;\n    var numDec = 0;\n\n    if (isFinite(step)) {\n      while (Math.round(step * Math.pow(10, numDec)) / Math.pow(10, numDec) !== step) {\n        numDec++;\n      }\n    } // Make sure value has correct number of decimal places based on number of decimals in step\n\n\n    var roundedValue = parseFloat(newValue.toFixed(numDec));\n    internalState.isBetweenSteps = newUnroundedValue !== undefined && newUnroundedValue !== roundedValue;\n\n    if (ranged) {\n      // decided which thumb value to change\n      if (internalState.isAdjustingLowerValue && (originFromZero ? roundedValue <= 0 : roundedValue <= internalState.latestValue)) {\n        setLowerValue(roundedValue, ev);\n      } else if (!internalState.isAdjustingLowerValue && (originFromZero ? roundedValue >= 0 : roundedValue >= internalState.latestLowerValue)) {\n        setValue(roundedValue, ev);\n      }\n    } else {\n      setValue(roundedValue, ev);\n    }\n  };\n\n  var onKeyDown = function onKeyDown(event) {\n    var newCurrentValue = internalState.isAdjustingLowerValue ? internalState.latestLowerValue : internalState.latestValue;\n    var diff = 0; // eslint-disable-next-line deprecation/deprecation\n\n    switch (event.which) {\n      case getRTLSafeKeyCode(KeyCodes.left, props.theme):\n      case KeyCodes.down:\n        diff = -step;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n\n      case getRTLSafeKeyCode(KeyCodes.right, props.theme):\n      case KeyCodes.up:\n        diff = step;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n\n      case KeyCodes.home:\n        newCurrentValue = min;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n\n      case KeyCodes.end:\n        newCurrentValue = max;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n\n      default:\n        return;\n    }\n\n    updateValue(event, newCurrentValue + diff);\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  var getPosition = function getPosition(event, verticalProp) {\n    var currentPosition = 0;\n\n    switch (event.type) {\n      case 'mousedown':\n      case 'mousemove':\n        currentPosition = !verticalProp ? event.clientX : event.clientY;\n        break;\n\n      case 'touchstart':\n      case 'touchmove':\n        currentPosition = !verticalProp ? event.touches[0].clientX : event.touches[0].clientY;\n        break;\n    }\n\n    return currentPosition;\n  };\n\n  var calculateCurrentSteps = function calculateCurrentSteps(event) {\n    var sliderPositionRect = sliderLine.current.getBoundingClientRect();\n    var sliderLength = !props.vertical ? sliderPositionRect.width : sliderPositionRect.height;\n    var stepLength = sliderLength / steps;\n    var currentSteps;\n    var distance;\n\n    if (!props.vertical) {\n      var left = getPosition(event, props.vertical);\n      distance = getRTL(props.theme) ? sliderPositionRect.right - left : left - sliderPositionRect.left;\n      currentSteps = distance / stepLength;\n    } else {\n      var bottom = getPosition(event, props.vertical);\n      distance = sliderPositionRect.bottom - bottom;\n      currentSteps = distance / stepLength;\n    }\n\n    return currentSteps;\n  };\n\n  var onMouseMoveOrTouchMove = function onMouseMoveOrTouchMove(event, suppressEventCancelation) {\n    var currentSteps = calculateCurrentSteps(event);\n    var newUnroundedValue = min + step * currentSteps;\n    var newCurrentValue = min + step * Math.round(currentSteps);\n    updateValue(event, newCurrentValue, newUnroundedValue);\n\n    if (!suppressEventCancelation) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  };\n\n  var onMouseDownOrTouchStart = function onMouseDownOrTouchStart(event) {\n    if (ranged) {\n      var currentSteps = calculateCurrentSteps(event);\n      var newValue = min + step * currentSteps;\n      internalState.isAdjustingLowerValue = newValue <= internalState.latestLowerValue || newValue - internalState.latestLowerValue <= internalState.latestValue - newValue;\n    }\n\n    if (event.type === 'mousedown') {\n      disposables.current.push(on(window, 'mousemove', onMouseMoveOrTouchMove, true), on(window, 'mouseup', onMouseUpOrTouchEnd, true));\n    } else if (event.type === 'touchstart') {\n      disposables.current.push(on(window, 'touchmove', onMouseMoveOrTouchMove, true), on(window, 'touchend', onMouseUpOrTouchEnd, true));\n    }\n\n    onMouseMoveOrTouchMove(event, true);\n  };\n\n  var onMouseUpOrTouchEnd = function onMouseUpOrTouchEnd(event) {\n    // Done adjusting, so clear this value\n    internalState.isBetweenSteps = undefined;\n    onChanged === null || onChanged === void 0 ? void 0 : onChanged(event, internalState.latestValue, ranged ? [internalState.latestLowerValue, internalState.latestValue] : undefined);\n    disposeListeners();\n  };\n\n  var onThumbFocus = function onThumbFocus(event) {\n    internalState.isAdjustingLowerValue = event.target === lowerValueThumbRef.current;\n  };\n\n  var disposeListeners = function disposeListeners() {\n    disposables.current.forEach(function (dispose) {\n      return dispose();\n    });\n    disposables.current = [];\n  };\n\n  var lowerValueThumbRef = React.useRef(null);\n  var thumbRef = React.useRef(null);\n  useComponentRef(props, ranged && !vertical ? lowerValueThumbRef : thumbRef, value, ranged ? [lowerValue, value] : undefined);\n  var getPositionStyles = getSlotStyleFn(vertical ? 'bottom' : getRTL(props.theme) ? 'right' : 'left');\n  var getTrackStyles = getSlotStyleFn(vertical ? 'height' : 'width');\n  var originValue = originFromZero ? 0 : min;\n  var valuePercent = getPercent(value, min, max);\n  var lowerValuePercent = getPercent(lowerValue, min, max);\n  var originPercentOfLine = getPercent(originValue, min, max);\n  var activeSectionWidth = ranged ? valuePercent - lowerValuePercent : Math.abs(originPercentOfLine - valuePercent);\n  var topSectionWidth = Math.min(100 - valuePercent, 100 - originPercentOfLine);\n  var bottomSectionWidth = ranged ? lowerValuePercent : Math.min(valuePercent, originPercentOfLine);\n  var rootProps = {\n    className: classNames.root,\n    ref: ref\n  };\n  var labelProps = {\n    className: classNames.titleLabel,\n    children: label,\n    disabled: disabled,\n    htmlFor: ariaLabel ? undefined : id\n  };\n  var valueLabelProps = showValue ? {\n    className: classNames.valueLabel,\n    children: valueFormat ? valueFormat(value) : value,\n    disabled: disabled,\n    htmlFor: disabled ? id : undefined\n  } : undefined;\n  var lowerValueLabelProps = ranged && showValue ? {\n    className: classNames.valueLabel,\n    children: valueFormat ? valueFormat(lowerValue) : lowerValue,\n    disabled: disabled\n  } : undefined;\n  var zeroTickProps = originFromZero ? {\n    className: classNames.zeroTick,\n    style: getPositionStyles(originPercentOfLine)\n  } : undefined;\n  var trackActiveProps = {\n    className: css(classNames.lineContainer, classNames.activeSection),\n    style: getTrackStyles(activeSectionWidth)\n  };\n  var trackTopInactiveProps = {\n    className: css(classNames.lineContainer, classNames.inactiveSection),\n    style: getTrackStyles(topSectionWidth)\n  };\n  var trackBottomInactiveProps = {\n    className: css(classNames.lineContainer, classNames.inactiveSection),\n    style: getTrackStyles(bottomSectionWidth)\n  };\n\n  var sliderProps = __assign({\n    'aria-disabled': disabled,\n    role: 'slider',\n    tabIndex: disabled ? undefined : 0\n  }, {\n    'data-is-focusable': !disabled\n  });\n\n  var sliderBoxProps = __assign(__assign(__assign({\n    id: id,\n    className: css(classNames.slideBox, buttonProps.className)\n  }, !disabled && {\n    onMouseDown: onMouseDownOrTouchStart,\n    onTouchStart: onMouseDownOrTouchStart,\n    onKeyDown: onKeyDown\n  }), buttonProps && getNativeProps(buttonProps, divProperties, ['id', 'className'])), !ranged && __assign(__assign({}, sliderProps), {\n    'aria-valuemin': min,\n    'aria-valuemax': max,\n    'aria-valuenow': value,\n    'aria-valuetext': getAriaValueText(value),\n    'aria-label': ariaLabel || label,\n    'aria-labelledby': ariaLabelledBy\n  }));\n\n  var onFocusProp = disabled ? {} : {\n    onFocus: onThumbFocus\n  };\n\n  var thumbProps = __assign({\n    ref: thumbRef,\n    className: classNames.thumb,\n    style: getPositionStyles(valuePercent)\n  }, ranged && __assign(__assign(__assign({}, sliderProps), onFocusProp), {\n    id: \"max-\" + id,\n    'aria-valuemin': lowerValue,\n    'aria-valuemax': max,\n    'aria-valuenow': value,\n    'aria-valuetext': getAriaValueText(value),\n    'aria-label': \"max \" + (ariaLabel || label)\n  }));\n\n  var lowerValueThumbProps = ranged ? __assign(__assign(__assign({\n    ref: lowerValueThumbRef,\n    className: classNames.thumb,\n    style: getPositionStyles(lowerValuePercent)\n  }, sliderProps), onFocusProp), {\n    id: \"min-\" + id,\n    'aria-valuemin': min,\n    'aria-valuemax': value,\n    'aria-valuenow': lowerValue,\n    'aria-valuetext': getAriaValueText(lowerValue),\n    'aria-label': \"min \" + (ariaLabel || label)\n  }) : undefined;\n  var containerProps = {\n    className: classNames.container\n  };\n  var sliderLineProps = {\n    ref: sliderLine,\n    className: classNames.line\n  };\n  return {\n    root: rootProps,\n    label: labelProps,\n    sliderBox: sliderBoxProps,\n    container: containerProps,\n    valueLabel: valueLabelProps,\n    lowerValueLabel: lowerValueLabelProps,\n    thumb: thumbProps,\n    lowerValueThumb: lowerValueThumbProps,\n    zeroTick: zeroTickProps,\n    activeTrack: trackActiveProps,\n    topInactiveTrack: trackTopInactiveProps,\n    bottomInactiveTrack: trackBottomInactiveProps,\n    sliderLine: sliderLineProps\n  };\n};","map":{"version":3,"mappings":"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","names":["React","useId","useControllableValue","useConst","useSetTimeout","KeyCodes","css","getRTL","getRTLSafeKeyCode","on","classNamesFunction","getNativeProps","divProperties","ONKEYDOWN_TIMEOUT_DURATION","getClassNames","getSlotStyleFn","sty","value","_a","getPercent","sliderMin","sliderMax","useComponentRef","props","thumb","range","useImperativeHandle","componentRef","focus","current","useSlider","ref","className","_b","disabled","label","_c","max","_d","min","_e","showValue","_f","buttonProps","_g","vertical","snapToStep","valueFormat","styles","theme","originFromZero","ariaLabelledBy","ariaLabel","ranged","onChange","onChanged","disposables","useRef","setTimeout","clearTimeout","sliderLine","defaultValue","ev","v","internalState","latestLowerValue","undefined","unclampedValue","setValue","lowerValue","defaultLowerValue","lv","latestValue","unclampedLowerValue","setLowerValue","Math","onKeyDownTimer","isAdjustingLowerValue","id","classNames","showTransitions","isBetweenSteps","steps","step","clearOnKeyDownTimer","setOnKeyDownTimer","event","getAriaValueText","valueProps","ariaValueText","toString","updateValue","newValue","newUnroundedValue","numDec","isFinite","round","pow","roundedValue","parseFloat","toFixed","onKeyDown","newCurrentValue","diff","which","left","down","right","up","home","end","preventDefault","stopPropagation","getPosition","verticalProp","currentPosition","type","clientX","clientY","touches","calculateCurrentSteps","sliderPositionRect","getBoundingClientRect","sliderLength","width","height","stepLength","currentSteps","distance","bottom","onMouseMoveOrTouchMove","suppressEventCancelation","onMouseDownOrTouchStart","push","window","onMouseUpOrTouchEnd","disposeListeners","onThumbFocus","target","lowerValueThumbRef","forEach","thumbRef","getPositionStyles","getTrackStyles","originValue","valuePercent","lowerValuePercent","originPercentOfLine","activeSectionWidth","abs","topSectionWidth","bottomSectionWidth","rootProps","root","labelProps","titleLabel","children","htmlFor","valueLabelProps","valueLabel","lowerValueLabelProps","zeroTickProps","zeroTick","style","trackActiveProps","lineContainer","activeSection","trackTopInactiveProps","inactiveSection","trackBottomInactiveProps","sliderProps","role","tabIndex","sliderBoxProps","slideBox","onMouseDown","onTouchStart","__assign","onFocusProp","onFocus","thumbProps","lowerValueThumbProps","containerProps","container","sliderLineProps","line","sliderBox","lowerValueLabel","lowerValueThumb","activeTrack","topInactiveTrack","bottomInactiveTrack"],"sources":["/home/runner/work/Reaction/Reaction/employee-info/node_modules/@fluentui/react/lib/components/src/components/Slider/useSlider.ts"],"sourcesContent":["import * as React from 'react';\nimport { useId, useControllableValue, useConst, useSetTimeout } from '@fluentui/react-hooks';\nimport {\n  KeyCodes,\n  css,\n  getRTL,\n  getRTLSafeKeyCode,\n  on,\n  classNamesFunction,\n  getNativeProps,\n  divProperties,\n} from '@fluentui/utilities';\nimport type { ISliderProps, ISliderStyleProps, ISliderStyles } from './Slider.types';\nimport type { ILabelProps } from '../Label/index';\n\nexport const ONKEYDOWN_TIMEOUT_DURATION = 1000;\n\ninterface ISliderInternalState {\n  onKeyDownTimer: number;\n  /** For a ranged slider, whether the thumb currently being dragged is the lower value one. */\n  isAdjustingLowerValue: boolean;\n  /** Allows access to the latest `value` inside reused callbacks (to avoid stale capture issues) */\n  latestValue: number;\n  /** Allows access to the latest `lowerValue` inside reused callbacks (to avoid stale capture issues) */\n  latestLowerValue: number;\n  /**\n   * Whether the user is currently dragging the thumb and it's between step intervals.\n   * (If true, and `props.snapToStep` is falsy, transition animations will be disabled.)\n   */\n  isBetweenSteps?: boolean;\n}\n\nconst getClassNames = classNamesFunction<ISliderStyleProps, ISliderStyles>();\n\ntype Dimension = 'height' | 'width';\ntype Position = 'bottom' | 'left' | 'right';\ntype PositionOrDimension = Dimension | Position;\n/** All the possible event types for a change event */\ntype ChangeEvent = Parameters<Required<ISliderProps>['onChange']>[2];\n/** All the possible event types for a change event that's dragging the slider (mouse or touch) */\ntype DragChangeEvent = React.MouseEvent | React.TouchEvent | MouseEvent | TouchEvent;\n\nconst getSlotStyleFn = (sty: PositionOrDimension) => {\n  return (value: number) => {\n    return {\n      [sty]: `${value}%`,\n    };\n  };\n};\n\nconst getPercent = (value: number, sliderMin: number, sliderMax: number) => {\n  return sliderMax === sliderMin ? 0 : ((value - sliderMin) / (sliderMax - sliderMin)) * 100;\n};\n\nconst useComponentRef = (\n  props: ISliderProps,\n  thumb: React.RefObject<HTMLSpanElement>,\n  value: number | undefined,\n  range: [number, number] | undefined,\n) => {\n  React.useImperativeHandle(\n    props.componentRef,\n    () => ({\n      get value() {\n        return value;\n      },\n      get range() {\n        return range;\n      },\n      focus() {\n        if (thumb.current) {\n          thumb.current.focus();\n        }\n      },\n    }),\n    [thumb, value, range],\n  );\n};\n\nexport const useSlider = (props: ISliderProps, ref: React.Ref<HTMLDivElement>) => {\n  const {\n    step = 1,\n    className,\n    disabled = false,\n    label,\n    max = 10,\n    min = 0,\n    showValue = true,\n    buttonProps = {},\n    vertical = false,\n    snapToStep,\n    valueFormat,\n    styles,\n    theme,\n    originFromZero,\n    'aria-labelledby': ariaLabelledBy,\n    'aria-label': ariaLabel,\n    ranged,\n    onChange,\n    onChanged,\n  } = props;\n\n  const disposables = React.useRef<(() => void)[]>([]);\n  const { setTimeout, clearTimeout } = useSetTimeout();\n  const sliderLine = React.useRef<HTMLDivElement>(null);\n\n  // Casting here is necessary because useControllableValue expects the event for the change callback\n  // to extend React.SyntheticEvent, when in fact for Slider, the event could be either a React event\n  // or a native browser event depending on the context.\n  const [unclampedValue, setValue] = useControllableValue(props.value, props.defaultValue, (ev: any, v) =>\n    onChange?.(v!, ranged ? [internalState.latestLowerValue, v!] : undefined, ev),\n  ) as [number | undefined, (v: number | undefined, ev: ChangeEvent) => void];\n  const [unclampedLowerValue, setLowerValue] = useControllableValue(\n    props.lowerValue,\n    props.defaultLowerValue,\n    (ev: any, lv) => onChange?.(internalState.latestValue, [lv!, internalState.latestValue], ev),\n  ) as [number | undefined, (v: number | undefined, ev: ChangeEvent) => void];\n\n  // Ensure that value is always a number and is clamped by min/max.\n  const value = Math.max(min, Math.min(max, unclampedValue || 0));\n  const lowerValue = Math.max(min, Math.min(value, unclampedLowerValue || 0));\n\n  const internalState = useConst<ISliderInternalState>({\n    onKeyDownTimer: -1,\n    isAdjustingLowerValue: false,\n    latestValue: value,\n    latestLowerValue: lowerValue,\n  });\n  // On each render, update this saved value used by callbacks. (This should be safe even if render\n  // is called multiple times, because an event handler or timeout callback will only run once.)\n  internalState.latestValue = value;\n  internalState.latestLowerValue = lowerValue;\n\n  const id = useId('Slider', props.id || buttonProps?.id);\n  const classNames = getClassNames(styles, {\n    className,\n    disabled,\n    vertical,\n    showTransitions: !snapToStep && !internalState.isBetweenSteps,\n    showValue,\n    ranged,\n    theme: theme!,\n  });\n\n  const steps = (max - min) / step;\n\n  const clearOnKeyDownTimer = (): void => {\n    clearTimeout(internalState.onKeyDownTimer);\n    internalState.onKeyDownTimer = -1;\n  };\n\n  const setOnKeyDownTimer = (event: React.KeyboardEvent) => {\n    clearOnKeyDownTimer();\n    if (onChanged) {\n      internalState.onKeyDownTimer = setTimeout(() => {\n        onChanged(\n          event,\n          internalState.latestValue,\n          ranged ? [internalState.latestLowerValue, internalState.latestValue] : undefined,\n        );\n      }, ONKEYDOWN_TIMEOUT_DURATION);\n    }\n  };\n\n  const getAriaValueText = (valueProps: number | undefined): string | undefined => {\n    const { ariaValueText } = props;\n    if (valueProps !== undefined) {\n      return ariaValueText ? ariaValueText(valueProps) : valueProps.toString();\n    }\n    return undefined;\n  };\n\n  /**\n   * Update `value` or `lowerValue`, including clamping between min/max and rounding to\n   * appropriate precision.\n   * @param newValue - New current value of the slider, possibly rounded to a whole step.\n   * @param newUnroundedValue - Like `newValue` but without the rounding to a step. If this is\n   * provided and not equal to `newValue`, `internalState.isBetweenSteps` will be set, which\n   * may cause thumb movement animations to be disabled.\n   */\n  const updateValue = (ev: any, newValue: number, newUnroundedValue?: number): void => {\n    newValue = Math.min(max, Math.max(min, newValue));\n    newUnroundedValue = newUnroundedValue !== undefined ? Math.min(max, Math.max(min, newUnroundedValue)) : undefined;\n\n    let numDec = 0;\n    if (isFinite(step)) {\n      while (Math.round(step * Math.pow(10, numDec)) / Math.pow(10, numDec) !== step) {\n        numDec++;\n      }\n    }\n    // Make sure value has correct number of decimal places based on number of decimals in step\n    const roundedValue = parseFloat(newValue.toFixed(numDec));\n\n    internalState.isBetweenSteps = newUnroundedValue !== undefined && newUnroundedValue !== roundedValue;\n\n    if (ranged) {\n      // decided which thumb value to change\n      if (\n        internalState.isAdjustingLowerValue &&\n        (originFromZero ? roundedValue <= 0 : roundedValue <= internalState.latestValue)\n      ) {\n        setLowerValue(roundedValue, ev);\n      } else if (\n        !internalState.isAdjustingLowerValue &&\n        (originFromZero ? roundedValue >= 0 : roundedValue >= internalState.latestLowerValue)\n      ) {\n        setValue(roundedValue, ev);\n      }\n    } else {\n      setValue(roundedValue, ev);\n    }\n  };\n\n  const onKeyDown = (event: React.KeyboardEvent): void => {\n    let newCurrentValue = internalState.isAdjustingLowerValue\n      ? internalState.latestLowerValue\n      : internalState.latestValue;\n    let diff = 0;\n    // eslint-disable-next-line deprecation/deprecation\n    switch (event.which) {\n      case getRTLSafeKeyCode(KeyCodes.left, props.theme):\n      case KeyCodes.down:\n        diff = -step;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n      case getRTLSafeKeyCode(KeyCodes.right, props.theme):\n      case KeyCodes.up:\n        diff = step;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n      case KeyCodes.home:\n        newCurrentValue = min;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n      case KeyCodes.end:\n        newCurrentValue = max;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n      default:\n        return;\n    }\n    updateValue(event, newCurrentValue + diff);\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const getPosition = (event: DragChangeEvent, verticalProp: boolean | undefined): number => {\n    let currentPosition = 0;\n    switch (event.type) {\n      case 'mousedown':\n      case 'mousemove':\n        currentPosition = !verticalProp ? (event as MouseEvent).clientX : (event as MouseEvent).clientY;\n        break;\n      case 'touchstart':\n      case 'touchmove':\n        currentPosition = !verticalProp\n          ? (event as TouchEvent).touches[0].clientX\n          : (event as TouchEvent).touches[0].clientY;\n        break;\n    }\n    return currentPosition;\n  };\n\n  const calculateCurrentSteps = (event: DragChangeEvent) => {\n    const sliderPositionRect: ClientRect = sliderLine.current!.getBoundingClientRect();\n    const sliderLength: number = !props.vertical ? sliderPositionRect.width : sliderPositionRect.height;\n    const stepLength: number = sliderLength / steps;\n    let currentSteps: number;\n    let distance: number;\n    if (!props.vertical) {\n      const left = getPosition(event, props.vertical);\n      distance = getRTL(props.theme) ? sliderPositionRect.right - left : left - sliderPositionRect.left;\n      currentSteps = distance / stepLength;\n    } else {\n      const bottom = getPosition(event, props.vertical);\n      distance = sliderPositionRect.bottom - bottom;\n      currentSteps = distance / stepLength;\n    }\n    return currentSteps;\n  };\n\n  const onMouseMoveOrTouchMove = (event: DragChangeEvent, suppressEventCancelation?: boolean): void => {\n    const currentSteps = calculateCurrentSteps(event);\n    const newUnroundedValue = min + step * currentSteps;\n    const newCurrentValue = min + step * Math.round(currentSteps);\n    updateValue(event, newCurrentValue, newUnroundedValue);\n    if (!suppressEventCancelation) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  };\n\n  const onMouseDownOrTouchStart = (event: React.MouseEvent | React.TouchEvent): void => {\n    if (ranged) {\n      const currentSteps = calculateCurrentSteps(event);\n      const newValue = min + step * currentSteps;\n\n      internalState.isAdjustingLowerValue =\n        newValue <= internalState.latestLowerValue ||\n        newValue - internalState.latestLowerValue <= internalState.latestValue - newValue;\n    }\n\n    if (event.type === 'mousedown') {\n      disposables.current.push(\n        on(window, 'mousemove', onMouseMoveOrTouchMove as (ev: Event) => void, true),\n        on(window, 'mouseup', onMouseUpOrTouchEnd, true),\n      );\n    } else if (event.type === 'touchstart') {\n      disposables.current.push(\n        on(window, 'touchmove', onMouseMoveOrTouchMove as (ev: Event) => void, true),\n        on(window, 'touchend', onMouseUpOrTouchEnd, true),\n      );\n    }\n    onMouseMoveOrTouchMove(event, true);\n  };\n\n  const onMouseUpOrTouchEnd = (event: MouseEvent | TouchEvent): void => {\n    // Done adjusting, so clear this value\n    internalState.isBetweenSteps = undefined;\n\n    onChanged?.(\n      event,\n      internalState.latestValue,\n      ranged ? [internalState.latestLowerValue, internalState.latestValue] : undefined,\n    );\n    disposeListeners();\n  };\n\n  const onThumbFocus = (event: React.FocusEvent): void => {\n    internalState.isAdjustingLowerValue = event.target === lowerValueThumbRef.current;\n  };\n\n  const disposeListeners = (): void => {\n    disposables.current.forEach(dispose => dispose());\n    disposables.current = [];\n  };\n\n  const lowerValueThumbRef = React.useRef<HTMLElement>(null);\n  const thumbRef = React.useRef<HTMLElement>(null);\n  useComponentRef(\n    props,\n    ranged && !vertical ? lowerValueThumbRef : thumbRef,\n    value,\n    ranged ? [lowerValue, value] : undefined,\n  );\n  const getPositionStyles = getSlotStyleFn(vertical ? 'bottom' : getRTL(props.theme) ? 'right' : 'left');\n  const getTrackStyles = getSlotStyleFn(vertical ? 'height' : 'width');\n  const originValue = originFromZero ? 0 : min;\n  const valuePercent = getPercent(value, min, max);\n  const lowerValuePercent = getPercent(lowerValue, min, max);\n  const originPercentOfLine = getPercent(originValue, min, max);\n  const activeSectionWidth = ranged ? valuePercent - lowerValuePercent : Math.abs(originPercentOfLine - valuePercent);\n  const topSectionWidth = Math.min(100 - valuePercent, 100 - originPercentOfLine);\n  const bottomSectionWidth = ranged ? lowerValuePercent : Math.min(valuePercent, originPercentOfLine);\n\n  const rootProps: React.HTMLAttributes<HTMLDivElement> & React.RefAttributes<HTMLDivElement> = {\n    className: classNames.root,\n    ref: ref,\n  };\n\n  const labelProps: ILabelProps = {\n    className: classNames.titleLabel,\n    children: label,\n    disabled,\n    htmlFor: ariaLabel ? undefined : id,\n  };\n\n  const valueLabelProps: ILabelProps | undefined = showValue\n    ? {\n        className: classNames.valueLabel,\n        children: valueFormat ? valueFormat(value) : value,\n        disabled,\n        htmlFor: disabled ? id : undefined,\n      }\n    : undefined;\n\n  const lowerValueLabelProps: ILabelProps | undefined =\n    ranged && showValue\n      ? {\n          className: classNames.valueLabel,\n          children: valueFormat ? valueFormat(lowerValue) : lowerValue,\n          disabled,\n        }\n      : undefined;\n\n  const zeroTickProps: React.HTMLAttributes<HTMLElement> | undefined = originFromZero\n    ? {\n        className: classNames.zeroTick,\n        style: getPositionStyles(originPercentOfLine),\n      }\n    : undefined;\n\n  const trackActiveProps: React.HTMLAttributes<HTMLElement> = {\n    className: css(classNames.lineContainer, classNames.activeSection),\n    style: getTrackStyles(activeSectionWidth),\n  };\n\n  const trackTopInactiveProps: React.HTMLAttributes<HTMLElement> = {\n    className: css(classNames.lineContainer, classNames.inactiveSection),\n    style: getTrackStyles(topSectionWidth),\n  };\n\n  const trackBottomInactiveProps: React.HTMLAttributes<HTMLElement> = {\n    className: css(classNames.lineContainer, classNames.inactiveSection),\n    style: getTrackStyles(bottomSectionWidth),\n  };\n\n  const sliderProps: React.HTMLAttributes<HTMLElement> = {\n    'aria-disabled': disabled,\n    role: 'slider',\n    tabIndex: disabled ? undefined : 0,\n    ...({ 'data-is-focusable': !disabled } as any),\n  };\n\n  const sliderBoxProps: React.HTMLAttributes<HTMLElement> = {\n    id,\n    className: css(classNames.slideBox, buttonProps.className),\n    ...(!disabled && {\n      onMouseDown: onMouseDownOrTouchStart,\n      onTouchStart: onMouseDownOrTouchStart,\n      onKeyDown: onKeyDown,\n    }),\n    ...(buttonProps &&\n      getNativeProps<React.HTMLAttributes<HTMLDivElement>>(buttonProps, divProperties, ['id', 'className'])),\n    ...(!ranged && {\n      ...sliderProps,\n      'aria-valuemin': min,\n      'aria-valuemax': max,\n      'aria-valuenow': value,\n      'aria-valuetext': getAriaValueText(value),\n      'aria-label': ariaLabel || label,\n      'aria-labelledby': ariaLabelledBy,\n    }),\n  };\n\n  const onFocusProp = disabled ? {} : { onFocus: onThumbFocus };\n\n  const thumbProps: React.HTMLAttributes<HTMLElement> & React.RefAttributes<HTMLElement> = {\n    ref: thumbRef,\n    className: classNames.thumb,\n    style: getPositionStyles(valuePercent),\n    ...(ranged && {\n      ...sliderProps,\n      ...onFocusProp,\n      id: `max-${id}`,\n      'aria-valuemin': lowerValue,\n      'aria-valuemax': max,\n      'aria-valuenow': value,\n      'aria-valuetext': getAriaValueText(value),\n      'aria-label': `max ${ariaLabel || label}`,\n    }),\n  };\n\n  const lowerValueThumbProps:\n    | (React.HTMLAttributes<HTMLElement> & React.RefAttributes<HTMLElement>)\n    | undefined = ranged\n    ? {\n        ref: lowerValueThumbRef,\n        className: classNames.thumb,\n        style: getPositionStyles(lowerValuePercent),\n        ...sliderProps,\n        ...onFocusProp,\n        id: `min-${id}`,\n        'aria-valuemin': min,\n        'aria-valuemax': value,\n        'aria-valuenow': lowerValue,\n        'aria-valuetext': getAriaValueText(lowerValue),\n        'aria-label': `min ${ariaLabel || label}`,\n      }\n    : undefined;\n\n  const containerProps: React.HTMLAttributes<HTMLElement> = {\n    className: classNames.container,\n  };\n\n  const sliderLineProps: React.HTMLAttributes<HTMLDivElement> & React.RefAttributes<HTMLDivElement> = {\n    ref: sliderLine,\n    className: classNames.line,\n  };\n\n  return {\n    root: rootProps,\n    label: labelProps,\n    sliderBox: sliderBoxProps,\n    container: containerProps,\n    valueLabel: valueLabelProps,\n    lowerValueLabel: lowerValueLabelProps,\n    thumb: thumbProps,\n    lowerValueThumb: lowerValueThumbProps,\n    zeroTick: zeroTickProps,\n    activeTrack: trackActiveProps,\n    topInactiveTrack: trackTopInactiveProps,\n    bottomInactiveTrack: trackBottomInactiveProps,\n    sliderLine: sliderLineProps,\n  };\n};\n"]},"metadata":{},"sourceType":"module"}