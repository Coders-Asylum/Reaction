{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, KeyCodes } from '../../Utilities';\nimport { ButtonGrid } from '../../utilities/ButtonGrid/ButtonGrid';\nimport { ColorPickerGridCell } from './ColorPickerGridCell';\nimport { useId, useConst, useSetTimeout, useControllableValue, useWarnings } from '@fluentui/react-hooks';\nvar getClassNames = classNamesFunction();\nvar COMPONENT_NAME = 'SwatchColorPicker';\n\nfunction useDebugWarnings(props) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: COMPONENT_NAME,\n      props: props,\n      mutuallyExclusive: {\n        focusOnHover: 'onHover',\n        selectedId: 'defaultSelectedId'\n      },\n      deprecations: {\n        isControlled: \"selectedId' or 'defaultSelectedId\",\n        onColorChanged: 'onChange'\n      }\n    });\n  }\n}\n\nexport var SwatchColorPickerBase = React.forwardRef(function (props, ref) {\n  var defaultId = useId('swatchColorPicker');\n  var id = props.id || defaultId;\n  var internalState = useConst({\n    isNavigationIdle: true,\n    cellFocused: false,\n    navigationIdleTimeoutId: undefined,\n    navigationIdleDelay: 250\n  });\n\n  var _a = useSetTimeout(),\n      setTimeout = _a.setTimeout,\n      clearTimeout = _a.clearTimeout;\n\n  useDebugWarnings(props);\n  var colorCells = props.colorCells,\n      _b = props.cellShape,\n      cellShape = _b === void 0 ? 'circle' : _b,\n      columnCount = props.columnCount,\n      _c = props.shouldFocusCircularNavigate,\n      shouldFocusCircularNavigate = _c === void 0 ? true : _c,\n      className = props.className,\n      _d = props.disabled,\n      disabled = _d === void 0 ? false : _d,\n      doNotContainWithinFocusZone = props.doNotContainWithinFocusZone,\n      styles = props.styles,\n      _e = props.cellMargin,\n      cellMargin = _e === void 0 ? 10 : _e,\n      defaultSelectedId = props.defaultSelectedId,\n      focusOnHover = props.focusOnHover,\n      mouseLeaveParentSelector = props.mouseLeaveParentSelector,\n      onChange = props.onChange,\n      // eslint-disable-next-line deprecation/deprecation\n  onColorChanged = props.onColorChanged,\n      onCellHovered = props.onCellHovered,\n      onCellFocused = props.onCellFocused,\n      getColorGridCellStyles = props.getColorGridCellStyles,\n      cellHeight = props.cellHeight,\n      cellWidth = props.cellWidth,\n      cellBorderWidth = props.cellBorderWidth;\n  /**\n   *  Add an index to each color cells. Memoizes this so that color cells do not re-render on every update.\n   */\n\n  var itemsWithIndex = React.useMemo(function () {\n    return colorCells.map(function (item, index) {\n      return __assign(__assign({}, item), {\n        index: index\n      });\n    });\n  }, [colorCells]);\n  var mergedOnChange = React.useCallback(function (ev, newSelectedId) {\n    var _a; // Call both new and old change handlers, and add the extra `color` parameter\n\n\n    var newColor = (_a = colorCells.filter(function (c) {\n      return c.id === newSelectedId;\n    })[0]) === null || _a === void 0 ? void 0 : _a.color;\n    onChange === null || onChange === void 0 ? void 0 : onChange(ev, newSelectedId, newColor);\n    onColorChanged === null || onColorChanged === void 0 ? void 0 : onColorChanged(newSelectedId, newColor);\n  }, [onChange, onColorChanged, colorCells]);\n\n  var _f = useControllableValue(props.selectedId, defaultSelectedId, mergedOnChange),\n      selectedId = _f[0],\n      setSelectedId = _f[1];\n\n  var classNames = getClassNames(styles, {\n    theme: props.theme,\n    className: className,\n    cellMargin: cellMargin\n  });\n  var gridStyles = {\n    root: classNames.root,\n    tableCell: classNames.tableCell,\n    focusedContainer: classNames.focusedContainer\n  };\n  /**\n   * If there is only one row of cells, they should use radio semantics,\n   * multi-row swatch cells should use grid semantics.\n   * There are two reasons for this:\n   *   1. Radios are a more simple and understandable control, and a better fit for a single-dimensional picker.\n   *   2. Multiple browsers use heuristics to strip table and grid roles from single-row tables with no column headers.\n   */\n\n  var isSemanticRadio = colorCells.length <= columnCount;\n  /**\n   * When the whole swatchColorPicker is blurred,\n   * make sure to clear the pending focused stated\n   */\n\n  var onSwatchColorPickerBlur = React.useCallback(function (event) {\n    if (onCellFocused) {\n      internalState.cellFocused = false;\n      onCellFocused(undefined, undefined, event);\n    }\n  }, [internalState, onCellFocused]);\n  /**\n   * Callback passed to the GridCell that will manage triggering the onCellHovered callback for mouseEnter\n   */\n\n  var onMouseEnter = React.useCallback(function (ev) {\n    if (!focusOnHover) {\n      return !internalState.isNavigationIdle || !!disabled;\n    }\n\n    if (internalState.isNavigationIdle && !disabled) {\n      ev.currentTarget.focus();\n    }\n\n    return true;\n  }, [focusOnHover, internalState, disabled]);\n  /**\n   * Callback passed to the GridCell that will manage Hover/Focus updates\n   */\n\n  var onMouseMove = React.useCallback(function (ev) {\n    if (!focusOnHover) {\n      return !internalState.isNavigationIdle || !!disabled;\n    }\n\n    var targetElement = ev.currentTarget; // If navigation is idle and the targetElement is the focused element bail out\n\n    if (internalState.isNavigationIdle && !(document && targetElement === document.activeElement)) {\n      targetElement.focus();\n    }\n\n    return true;\n  }, [focusOnHover, internalState, disabled]);\n  /**\n   * Callback passed to the GridCell that will manage Hover/Focus updates\n   */\n\n  var onMouseLeave = React.useCallback(function (ev) {\n    var parentSelector = mouseLeaveParentSelector;\n\n    if (!focusOnHover || !parentSelector || !internalState.isNavigationIdle || disabled) {\n      return;\n    } // Get the elements that math the given selector\n\n\n    var elements = document.querySelectorAll(parentSelector); // iterate over the elements return to make sure it is a parent of the target and focus it\n\n    for (var index = 0; index < elements.length; index += 1) {\n      if (elements[index].contains(ev.currentTarget)) {\n        /**\n         * IE11 focus() method forces parents to scroll to top of element.\n         * Edge and IE expose a setActive() function for focusable divs that\n         * sets the page focus but does not scroll the parent element.\n         */\n        if (elements[index].setActive) {\n          try {\n            elements[index].setActive();\n          } catch (e) {\n            /* no-op */\n          }\n        } else {\n          elements[index].focus();\n        }\n\n        break;\n      }\n    }\n  }, [disabled, focusOnHover, internalState, mouseLeaveParentSelector]);\n  /**\n   * Callback passed to the GridCell class that will trigger the onCellHovered callback of the SwatchColorPicker\n   * NOTE: This will not be triggered if shouldFocusOnHover === true\n   */\n\n  var onGridCellHovered = React.useCallback(function (item, event) {\n    if (onCellHovered) {\n      item ? onCellHovered(item.id, item.color, event) : onCellHovered(undefined, undefined, event);\n    }\n  }, [onCellHovered]);\n  /**\n   * Callback passed to the GridCell class that will trigger the onCellFocus callback of the SwatchColorPicker\n   */\n\n  var onGridCellFocused = React.useCallback(function (item, event) {\n    if (onCellFocused) {\n      if (item) {\n        internalState.cellFocused = true;\n        return onCellFocused(item.id, item.color, event);\n      } else {\n        internalState.cellFocused = false;\n        return onCellFocused(undefined, undefined, event);\n      }\n    }\n  }, [internalState, onCellFocused]);\n  /**\n   * Handle the click on a cell\n   */\n\n  var onCellClick = React.useCallback(function (item, event) {\n    if (disabled) {\n      return;\n    }\n\n    if (item.id !== selectedId) {\n      if (onCellFocused && internalState.cellFocused) {\n        internalState.cellFocused = false;\n        onCellFocused(undefined, undefined, event);\n      }\n\n      setSelectedId(item.id, event);\n    }\n  }, [disabled, internalState, onCellFocused, selectedId, setSelectedId]);\n  /**\n   * Sets a timeout so we won't process any mouse \"hover\" events\n   * while navigating (via mouseWheel or arrowKeys)\n   */\n\n  var setNavigationTimeout = React.useCallback(function () {\n    if (!internalState.isNavigationIdle && internalState.navigationIdleTimeoutId !== undefined) {\n      clearTimeout(internalState.navigationIdleTimeoutId);\n      internalState.navigationIdleTimeoutId = undefined;\n    } else {\n      internalState.isNavigationIdle = false;\n    }\n\n    internalState.navigationIdleTimeoutId = setTimeout(function () {\n      internalState.isNavigationIdle = true;\n    }, internalState.navigationIdleDelay);\n  }, [clearTimeout, internalState, setTimeout]);\n  /**\n   * Callback used to handle KeyCode events\n   */\n\n  var onKeyDown = React.useCallback(function (ev) {\n    if ( // eslint-disable-next-line deprecation/deprecation\n    ev.which === KeyCodes.up || // eslint-disable-next-line deprecation/deprecation\n    ev.which === KeyCodes.down || // eslint-disable-next-line deprecation/deprecation\n    ev.which === KeyCodes.left || // eslint-disable-next-line deprecation/deprecation\n    ev.which === KeyCodes.right) {\n      setNavigationTimeout();\n    }\n  }, [setNavigationTimeout]);\n  /**\n   * Render a color cell\n   * @param item - The item to render\n   * @returns - Element representing the item\n   */\n\n  var renderOption = function renderOption(item) {\n    return React.createElement(ColorPickerGridCell, {\n      item: item,\n      idPrefix: id,\n      color: item.color,\n      styles: getColorGridCellStyles,\n      disabled: disabled,\n      onClick: onCellClick,\n      onHover: onGridCellHovered,\n      onFocus: onGridCellFocused,\n      selected: selectedId === item.id,\n      circle: cellShape === 'circle',\n      label: item.label,\n      onMouseEnter: onMouseEnter,\n      onMouseMove: onMouseMove,\n      onMouseLeave: onMouseLeave,\n      onWheel: setNavigationTimeout,\n      onKeyDown: onKeyDown,\n      height: cellHeight,\n      width: cellWidth,\n      borderWidth: cellBorderWidth,\n      isRadio: isSemanticRadio\n    });\n  };\n\n  if (colorCells.length < 1 || columnCount < 1) {\n    return null;\n  }\n\n  var onRenderItem = function onRenderItem(item, index) {\n    var _a = props.onRenderColorCell,\n        onRenderColorCell = _a === void 0 ? renderOption : _a;\n    return onRenderColorCell(item, renderOption);\n  };\n\n  return React.createElement(ButtonGrid, __assign({}, props, {\n    ref: ref,\n    id: id,\n    items: itemsWithIndex,\n    columnCount: columnCount,\n    isSemanticRadio: isSemanticRadio,\n    // eslint-disable-next-line react/jsx-no-bind\n    onRenderItem: onRenderItem,\n    shouldFocusCircularNavigate: shouldFocusCircularNavigate,\n    doNotContainWithinFocusZone: doNotContainWithinFocusZone,\n    onBlur: onSwatchColorPickerBlur,\n    theme: props.theme,\n    styles: gridStyles\n  }));\n});\nSwatchColorPickerBase.displayName = COMPONENT_NAME;","map":{"version":3,"mappings":"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","names":["React","classNamesFunction","KeyCodes","ButtonGrid","ColorPickerGridCell","useId","useConst","useSetTimeout","useControllableValue","useWarnings","getClassNames","COMPONENT_NAME","useDebugWarnings","props","process","env","NODE_ENV","name","mutuallyExclusive","focusOnHover","selectedId","deprecations","isControlled","onColorChanged","SwatchColorPickerBase","forwardRef","ref","defaultId","id","internalState","isNavigationIdle","cellFocused","navigationIdleTimeoutId","undefined","navigationIdleDelay","setTimeout","clearTimeout","_b","cellShape","columnCount","_c","shouldFocusCircularNavigate","className","_d","disabled","doNotContainWithinFocusZone","styles","_e","cellMargin","defaultSelectedId","mouseLeaveParentSelector","onChange","onCellHovered","onCellFocused","getColorGridCellStyles","cellHeight","cellWidth","cellBorderWidth","itemsWithIndex","useMemo","colorCells","map","item","index","mergedOnChange","useCallback","ev","newSelectedId","newColor","filter","_a","color","setSelectedId","classNames","theme","gridStyles","root","tableCell","focusedContainer","isSemanticRadio","length","onSwatchColorPickerBlur","event","onMouseEnter","currentTarget","focus","onMouseMove","targetElement","document","activeElement","onMouseLeave","parentSelector","elements","querySelectorAll","contains","setActive","e","onGridCellHovered","onGridCellFocused","onCellClick","setNavigationTimeout","onKeyDown","which","up","down","left","right","renderOption","idPrefix","onClick","onHover","onFocus","selected","circle","label","onWheel","height","width","borderWidth","isRadio","onRenderItem","onRenderColorCell","__assign","items","onBlur","displayName"],"sources":["/home/runner/work/Reaction/Reaction/employee-info/node_modules/@fluentui/react/lib/components/src/components/SwatchColorPicker/SwatchColorPicker.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNamesFunction, KeyCodes } from '../../Utilities';\nimport { ButtonGrid } from '../../utilities/ButtonGrid/ButtonGrid';\nimport { ColorPickerGridCell } from './ColorPickerGridCell';\nimport { useId, useConst, useSetTimeout, useControllableValue, useWarnings } from '@fluentui/react-hooks';\nimport type {\n  ISwatchColorPickerProps,\n  ISwatchColorPickerStyleProps,\n  ISwatchColorPickerStyles,\n} from './SwatchColorPicker.types';\nimport type { IColorCellProps } from './ColorPickerGridCell.types';\nimport type { IButtonGridProps } from '../../utilities/ButtonGrid/ButtonGrid.types';\n\ninterface ISwatchColorPickerInternalState {\n  isNavigationIdle: boolean;\n  cellFocused: boolean;\n  navigationIdleTimeoutId: number | undefined;\n  navigationIdleDelay: number;\n}\n\nconst getClassNames = classNamesFunction<ISwatchColorPickerStyleProps, ISwatchColorPickerStyles>();\n\nconst COMPONENT_NAME = 'SwatchColorPicker';\n\nfunction useDebugWarnings(props: ISwatchColorPickerProps) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: COMPONENT_NAME,\n      props,\n      mutuallyExclusive: { focusOnHover: 'onHover', selectedId: 'defaultSelectedId' },\n      deprecations: { isControlled: \"selectedId' or 'defaultSelectedId\", onColorChanged: 'onChange' },\n    });\n  }\n}\n\nexport const SwatchColorPickerBase: React.FunctionComponent<ISwatchColorPickerProps> = React.forwardRef<\n  HTMLElement,\n  ISwatchColorPickerProps\n>((props, ref) => {\n  const defaultId = useId('swatchColorPicker');\n  const id = props.id || defaultId;\n\n  const internalState = useConst<ISwatchColorPickerInternalState>({\n    isNavigationIdle: true,\n    cellFocused: false,\n    navigationIdleTimeoutId: undefined,\n    navigationIdleDelay: 250,\n  });\n\n  const { setTimeout, clearTimeout } = useSetTimeout();\n\n  useDebugWarnings(props);\n\n  const {\n    colorCells,\n    cellShape = 'circle',\n    columnCount,\n    shouldFocusCircularNavigate = true,\n    className,\n    disabled = false,\n    doNotContainWithinFocusZone,\n    styles,\n    cellMargin = 10,\n    defaultSelectedId,\n    focusOnHover,\n    mouseLeaveParentSelector,\n    onChange,\n    // eslint-disable-next-line deprecation/deprecation\n    onColorChanged,\n    onCellHovered,\n    onCellFocused,\n    getColorGridCellStyles,\n    cellHeight,\n    cellWidth,\n    cellBorderWidth,\n  } = props;\n\n  /**\n   *  Add an index to each color cells. Memoizes this so that color cells do not re-render on every update.\n   */\n  const itemsWithIndex = React.useMemo(() => {\n    return colorCells.map((item, index) => {\n      return { ...item, index: index };\n    });\n  }, [colorCells]);\n\n  const mergedOnChange = React.useCallback(\n    (ev: React.FormEvent<HTMLElement>, newSelectedId: string | undefined) => {\n      // Call both new and old change handlers, and add the extra `color` parameter\n      const newColor = colorCells.filter(c => c.id === newSelectedId)[0]?.color;\n      onChange?.(ev, newSelectedId, newColor);\n      onColorChanged?.(newSelectedId, newColor);\n    },\n    [onChange, onColorChanged, colorCells],\n  );\n\n  const [selectedId, setSelectedId] = useControllableValue(props.selectedId, defaultSelectedId, mergedOnChange);\n\n  const classNames = getClassNames(styles!, {\n    theme: props.theme!,\n    className,\n    cellMargin,\n  });\n\n  const gridStyles = {\n    root: classNames.root,\n    tableCell: classNames.tableCell,\n    focusedContainer: classNames.focusedContainer,\n  };\n\n  /**\n   * If there is only one row of cells, they should use radio semantics,\n   * multi-row swatch cells should use grid semantics.\n   * There are two reasons for this:\n   *   1. Radios are a more simple and understandable control, and a better fit for a single-dimensional picker.\n   *   2. Multiple browsers use heuristics to strip table and grid roles from single-row tables with no column headers.\n   */\n  const isSemanticRadio = colorCells.length <= columnCount;\n\n  /**\n   * When the whole swatchColorPicker is blurred,\n   * make sure to clear the pending focused stated\n   */\n  const onSwatchColorPickerBlur = React.useCallback(\n    (event?: React.FocusEvent<HTMLButtonElement>): void => {\n      if (onCellFocused) {\n        internalState.cellFocused = false;\n        onCellFocused(undefined, undefined, event);\n      }\n    },\n    [internalState, onCellFocused],\n  );\n\n  /**\n   * Callback passed to the GridCell that will manage triggering the onCellHovered callback for mouseEnter\n   */\n  const onMouseEnter = React.useCallback(\n    (ev: React.MouseEvent<HTMLButtonElement>): boolean => {\n      if (!focusOnHover) {\n        return !internalState.isNavigationIdle || !!disabled;\n      }\n      if (internalState.isNavigationIdle && !disabled) {\n        ev.currentTarget.focus();\n      }\n      return true;\n    },\n    [focusOnHover, internalState, disabled],\n  );\n\n  /**\n   * Callback passed to the GridCell that will manage Hover/Focus updates\n   */\n  const onMouseMove = React.useCallback(\n    (ev: React.MouseEvent<HTMLButtonElement>): boolean => {\n      if (!focusOnHover) {\n        return !internalState.isNavigationIdle || !!disabled;\n      }\n\n      const targetElement = ev.currentTarget as HTMLElement;\n\n      // If navigation is idle and the targetElement is the focused element bail out\n      if (internalState.isNavigationIdle && !(document && targetElement === (document.activeElement as HTMLElement))) {\n        targetElement.focus();\n      }\n\n      return true;\n    },\n    [focusOnHover, internalState, disabled],\n  );\n\n  /**\n   * Callback passed to the GridCell that will manage Hover/Focus updates\n   */\n  const onMouseLeave = React.useCallback(\n    (ev: React.MouseEvent<HTMLButtonElement>): void => {\n      const parentSelector = mouseLeaveParentSelector;\n\n      if (!focusOnHover || !parentSelector || !internalState.isNavigationIdle || disabled) {\n        return;\n      }\n\n      // Get the elements that math the given selector\n      const elements = document.querySelectorAll(parentSelector);\n\n      // iterate over the elements return to make sure it is a parent of the target and focus it\n      for (let index = 0; index < elements.length; index += 1) {\n        if (elements[index].contains(ev.currentTarget)) {\n          /**\n           * IE11 focus() method forces parents to scroll to top of element.\n           * Edge and IE expose a setActive() function for focusable divs that\n           * sets the page focus but does not scroll the parent element.\n           */\n          if ((elements[index] as any).setActive) {\n            try {\n              (elements[index] as any).setActive();\n            } catch (e) {\n              /* no-op */\n            }\n          } else {\n            (elements[index] as HTMLElement).focus();\n          }\n\n          break;\n        }\n      }\n    },\n    [disabled, focusOnHover, internalState, mouseLeaveParentSelector],\n  );\n\n  /**\n   * Callback passed to the GridCell class that will trigger the onCellHovered callback of the SwatchColorPicker\n   * NOTE: This will not be triggered if shouldFocusOnHover === true\n   */\n  const onGridCellHovered = React.useCallback(\n    (item?: IColorCellProps, event?: React.MouseEvent<HTMLButtonElement>): void => {\n      if (onCellHovered) {\n        item ? onCellHovered(item.id, item.color, event) : onCellHovered(undefined, undefined, event);\n      }\n    },\n    [onCellHovered],\n  );\n\n  /**\n   * Callback passed to the GridCell class that will trigger the onCellFocus callback of the SwatchColorPicker\n   */\n  const onGridCellFocused = React.useCallback(\n    (item?: IColorCellProps, event?: React.FormEvent<HTMLButtonElement>): void => {\n      if (onCellFocused) {\n        if (item) {\n          internalState.cellFocused = true;\n          return onCellFocused(item.id, item.color, event);\n        } else {\n          internalState.cellFocused = false;\n          return onCellFocused(undefined, undefined, event);\n        }\n      }\n    },\n    [internalState, onCellFocused],\n  );\n\n  /**\n   * Handle the click on a cell\n   */\n  const onCellClick = React.useCallback(\n    (item: IColorCellProps, event?: React.MouseEvent<HTMLButtonElement>): void => {\n      if (disabled) {\n        return;\n      }\n\n      if (item.id !== selectedId) {\n        if (onCellFocused && internalState.cellFocused) {\n          internalState.cellFocused = false;\n          onCellFocused(undefined, undefined, event);\n        }\n        setSelectedId(item.id, event);\n      }\n    },\n    [disabled, internalState, onCellFocused, selectedId, setSelectedId],\n  );\n\n  /**\n   * Sets a timeout so we won't process any mouse \"hover\" events\n   * while navigating (via mouseWheel or arrowKeys)\n   */\n  const setNavigationTimeout = React.useCallback(() => {\n    if (!internalState.isNavigationIdle && internalState.navigationIdleTimeoutId !== undefined) {\n      clearTimeout(internalState.navigationIdleTimeoutId);\n      internalState.navigationIdleTimeoutId = undefined;\n    } else {\n      internalState.isNavigationIdle = false;\n    }\n\n    internalState.navigationIdleTimeoutId = setTimeout(() => {\n      internalState.isNavigationIdle = true;\n    }, internalState.navigationIdleDelay);\n  }, [clearTimeout, internalState, setTimeout]);\n\n  /**\n   * Callback used to handle KeyCode events\n   */\n  const onKeyDown = React.useCallback(\n    (ev: React.KeyboardEvent<HTMLButtonElement>): void => {\n      if (\n        // eslint-disable-next-line deprecation/deprecation\n        ev.which === KeyCodes.up ||\n        // eslint-disable-next-line deprecation/deprecation\n        ev.which === KeyCodes.down ||\n        // eslint-disable-next-line deprecation/deprecation\n        ev.which === KeyCodes.left ||\n        // eslint-disable-next-line deprecation/deprecation\n        ev.which === KeyCodes.right\n      ) {\n        setNavigationTimeout();\n      }\n    },\n    [setNavigationTimeout],\n  );\n\n  /**\n   * Render a color cell\n   * @param item - The item to render\n   * @returns - Element representing the item\n   */\n  const renderOption = (item: IColorCellProps): JSX.Element => {\n    return (\n      <ColorPickerGridCell\n        item={item}\n        idPrefix={id}\n        color={item.color}\n        styles={getColorGridCellStyles}\n        disabled={disabled}\n        onClick={onCellClick}\n        onHover={onGridCellHovered}\n        onFocus={onGridCellFocused}\n        selected={selectedId === item.id}\n        circle={cellShape === 'circle'}\n        label={item.label}\n        onMouseEnter={onMouseEnter}\n        onMouseMove={onMouseMove}\n        onMouseLeave={onMouseLeave}\n        onWheel={setNavigationTimeout}\n        onKeyDown={onKeyDown}\n        height={cellHeight}\n        width={cellWidth}\n        borderWidth={cellBorderWidth}\n        isRadio={isSemanticRadio}\n      />\n    );\n  };\n\n  if (colorCells.length < 1 || columnCount < 1) {\n    return null;\n  }\n\n  const onRenderItem = (item: IColorCellProps, index: number): JSX.Element => {\n    const { onRenderColorCell = renderOption } = props;\n    return onRenderColorCell(item, renderOption) as JSX.Element;\n  };\n  return (\n    <ButtonGrid\n      {...((props as unknown) as IButtonGridProps)}\n      ref={ref}\n      id={id}\n      items={itemsWithIndex}\n      columnCount={columnCount}\n      isSemanticRadio={isSemanticRadio}\n      // eslint-disable-next-line react/jsx-no-bind\n      onRenderItem={onRenderItem}\n      shouldFocusCircularNavigate={shouldFocusCircularNavigate}\n      doNotContainWithinFocusZone={doNotContainWithinFocusZone}\n      onBlur={onSwatchColorPickerBlur}\n      theme={props.theme!}\n      styles={gridStyles}\n    />\n  );\n});\n\nSwatchColorPickerBase.displayName = COMPONENT_NAME;\n"]},"metadata":{},"sourceType":"module"}