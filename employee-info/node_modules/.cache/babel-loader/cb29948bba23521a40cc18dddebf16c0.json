{"ast":null,"code":"import * as React from 'react';\nimport { useIsomorphicLayoutEffect, useRefEffect } from '@fluentui/react-hooks';\nimport { getWindow } from '@fluentui/utilities';\nimport { observeResize } from './observeResize';\n/**\n * Track whether any items don't fit within their container, and move them to the overflow menu.\n * Items are moved into the overflow menu from back to front, excluding pinned items.\n *\n * The overflow menu button must be the last sibling of all of the items that can be put into the overflow, and it\n * must be hooked up to the `setMenuButtonRef` setter function that's returned by `useOverflow`:\n * ```ts\n * const overflow = useOverflow(...);\n * ```\n * ```jsx\n * <Container>\n *  <Item /> // Index 0\n *  <Item /> // Index 1\n *  ...\n *  <Button ref={overflow.setMenuButtonRef} /> // Can be any React.Component or HTMLElement\n * </Container>\n * ```\n */\n\nexport var useOverflow = function useOverflow(_a) {\n  var onOverflowItemsChanged = _a.onOverflowItemsChanged,\n      rtl = _a.rtl,\n      pinnedIndex = _a.pinnedIndex;\n  var updateOverflowRef = React.useRef();\n  var containerWidthRef = React.useRef(); // Attach a resize observer to the container\n\n  var containerRef = useRefEffect(function (container) {\n    var cleanupObserver = observeResize(container, function (entries) {\n      containerWidthRef.current = entries ? entries[0].contentRect.width : container.clientWidth;\n\n      if (updateOverflowRef.current) {\n        updateOverflowRef.current();\n      }\n    });\n    return function () {\n      cleanupObserver();\n      containerWidthRef.current = undefined;\n    };\n  });\n  var menuButtonRef = useRefEffect(function (menuButton) {\n    containerRef(menuButton.parentElement);\n    return function () {\n      return containerRef(null);\n    };\n  });\n  useIsomorphicLayoutEffect(function () {\n    var container = containerRef.current;\n    var menuButton = menuButtonRef.current;\n\n    if (!container || !menuButton) {\n      return;\n    } // items contains the container's children, excluding the overflow menu button itself\n\n\n    var items = [];\n\n    for (var i = 0; i < container.children.length; i++) {\n      var item = container.children[i];\n\n      if (item instanceof HTMLElement && item !== menuButton) {\n        items.push(item);\n      }\n    } // Keep track of the minimum width of the container to fit each child index.\n    // This cache is an integral part of the algorithm and not just a performance optimization: it allows us to\n    // recalculate the overflowIndex on subsequent resizes even if some items are already inside the overflow.\n\n\n    var minContainerWidth = [];\n    var extraWidth = 0; // The accumulated width of items that don't move into the overflow\n\n    updateOverflowRef.current = function () {\n      var containerWidth = containerWidthRef.current;\n\n      if (containerWidth === undefined) {\n        return;\n      } // Iterate the items in reverse order until we find one that fits within the bounds of the container\n\n\n      for (var i = items.length - 1; i >= 0; i--) {\n        // Calculate the min container width for this item if we haven't done so yet\n        if (minContainerWidth[i] === undefined) {\n          var itemOffsetEnd = rtl ? containerWidth - items[i].offsetLeft : items[i].offsetLeft + items[i].offsetWidth; // If the item after this one is pinned, reserve space for it\n\n          if (i + 1 < items.length && i + 1 === pinnedIndex) {\n            // Use distance between the end of the previous item and this one (rather than the\n            // pinned item's offsetWidth), to account for any margin between the items.\n            extraWidth = minContainerWidth[i + 1] - itemOffsetEnd;\n          } // Reserve space for the menu button after the first item was added to the overflow\n\n\n          if (i === items.length - 2) {\n            extraWidth += menuButton.offsetWidth;\n          }\n\n          minContainerWidth[i] = itemOffsetEnd + extraWidth;\n        }\n\n        if (containerWidth > minContainerWidth[i]) {\n          setOverflowIndex(i + 1);\n          return;\n        }\n      } // If we got here, nothing fits outside the overflow\n\n\n      setOverflowIndex(0);\n    };\n\n    var prevOverflowIndex = items.length;\n\n    var setOverflowIndex = function setOverflowIndex(overflowIndex) {\n      if (prevOverflowIndex !== overflowIndex) {\n        prevOverflowIndex = overflowIndex;\n        onOverflowItemsChanged(overflowIndex, items.map(function (ele, index) {\n          return {\n            ele: ele,\n            isOverflowing: index >= overflowIndex && index !== pinnedIndex\n          };\n        }));\n      }\n    };\n\n    var cancelAnimationFrame = undefined; // If the container width is already known from a previous render, update the overflow with its width.\n    // Do this in an animation frame to avoid forcing layout to happen early.\n\n    if (containerWidthRef.current !== undefined) {\n      var win_1 = getWindow(container);\n\n      if (win_1) {\n        var animationFrameId_1 = win_1.requestAnimationFrame(updateOverflowRef.current);\n\n        cancelAnimationFrame = function cancelAnimationFrame() {\n          return win_1.cancelAnimationFrame(animationFrameId_1);\n        };\n      }\n    }\n\n    return function () {\n      if (cancelAnimationFrame) {\n        cancelAnimationFrame();\n      } // On cleanup, need to remove all items from the overflow\n      // so they don't have stale properties on the next render\n\n\n      setOverflowIndex(items.length);\n      updateOverflowRef.current = undefined;\n    };\n  });\n  return {\n    menuButtonRef: menuButtonRef\n  };\n};","map":{"version":3,"mappings":"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","names":["React","useIsomorphicLayoutEffect","useRefEffect","getWindow","observeResize","useOverflow","_a","onOverflowItemsChanged","rtl","pinnedIndex","updateOverflowRef","useRef","containerWidthRef","containerRef","cleanupObserver","container","current","entries","contentRect","width","clientWidth","undefined","menuButtonRef","menuButton","parentElement","items","i","children","length","item","HTMLElement","push","minContainerWidth","extraWidth","containerWidth","itemOffsetEnd","offsetLeft","offsetWidth","setOverflowIndex","prevOverflowIndex","overflowIndex","map","ele","index","isOverflowing","cancelAnimationFrame","win_1","animationFrameId_1","requestAnimationFrame"],"sources":["/home/runner/work/Reaction/Reaction/employee-info/node_modules/@fluentui/react/lib/src/utilities/useOverflow.ts"],"sourcesContent":["import * as React from 'react';\nimport { useIsomorphicLayoutEffect, useRefEffect } from '@fluentui/react-hooks';\nimport { getWindow } from '@fluentui/utilities';\nimport { observeResize } from './observeResize';\nimport type { RefCallback } from '@fluentui/react-hooks';\n\n/**\n * Callback to notify the user that the items in the overflow have changed. This should ensure that the overflow menu\n * is visible, and contains all of the overflowing items.\n *\n * @param overflowIndex - The index of the first item in the overflow, or items.length if nothing is overflowing.\n * @param items - The list of all items in the container, and whether that particular item is in the overflow\n */\nexport type OverflowItemsChangedCallback = (\n  overflowIndex: number,\n  items: { ele: HTMLElement; isOverflowing: boolean }[],\n) => void;\n\n/** Parameters for {@see useOverflow} */\nexport type OverflowParams = {\n  /** Callback to notify the user that the items in the overflow have changed. */\n  onOverflowItemsChanged: OverflowItemsChangedCallback;\n\n  /** True if the element containing overflowMenuButtonRef is in right-to-left order */\n  rtl: boolean;\n\n  /** Optional: Index of item that should never go into the overflow menu. */\n  pinnedIndex?: number;\n};\n\n/** Return value for {@see useOverflow} */\nexport type OverflowRefs = {\n  /** Set the overflow menu button's ref to this ref callback */\n  menuButtonRef: RefCallback<HTMLElement>;\n};\n\n/**\n * Track whether any items don't fit within their container, and move them to the overflow menu.\n * Items are moved into the overflow menu from back to front, excluding pinned items.\n *\n * The overflow menu button must be the last sibling of all of the items that can be put into the overflow, and it\n * must be hooked up to the `setMenuButtonRef` setter function that's returned by `useOverflow`:\n * ```ts\n * const overflow = useOverflow(...);\n * ```\n * ```jsx\n * <Container>\n *  <Item /> // Index 0\n *  <Item /> // Index 1\n *  ...\n *  <Button ref={overflow.setMenuButtonRef} /> // Can be any React.Component or HTMLElement\n * </Container>\n * ```\n */\nexport const useOverflow = ({ onOverflowItemsChanged, rtl, pinnedIndex }: OverflowParams): OverflowRefs => {\n  const updateOverflowRef = React.useRef<() => void>();\n  const containerWidthRef = React.useRef<number>();\n\n  // Attach a resize observer to the container\n  const containerRef = useRefEffect<HTMLElement>(container => {\n    const cleanupObserver = observeResize(container, entries => {\n      containerWidthRef.current = entries ? entries[0].contentRect.width : container.clientWidth;\n      if (updateOverflowRef.current) {\n        updateOverflowRef.current();\n      }\n    });\n\n    return () => {\n      cleanupObserver();\n      containerWidthRef.current = undefined;\n    };\n  });\n\n  const menuButtonRef = useRefEffect<HTMLElement>(menuButton => {\n    containerRef(menuButton.parentElement);\n    return () => containerRef(null);\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    const container = containerRef.current;\n    const menuButton = menuButtonRef.current;\n    if (!container || !menuButton) {\n      return;\n    }\n\n    // items contains the container's children, excluding the overflow menu button itself\n    const items: HTMLElement[] = [];\n    for (let i = 0; i < container.children.length; i++) {\n      const item = container.children[i];\n      if (item instanceof HTMLElement && item !== menuButton) {\n        items.push(item);\n      }\n    }\n\n    // Keep track of the minimum width of the container to fit each child index.\n    // This cache is an integral part of the algorithm and not just a performance optimization: it allows us to\n    // recalculate the overflowIndex on subsequent resizes even if some items are already inside the overflow.\n    const minContainerWidth: number[] = [];\n    let extraWidth = 0; // The accumulated width of items that don't move into the overflow\n\n    updateOverflowRef.current = () => {\n      const containerWidth = containerWidthRef.current;\n      if (containerWidth === undefined) {\n        return;\n      }\n\n      // Iterate the items in reverse order until we find one that fits within the bounds of the container\n      for (let i = items.length - 1; i >= 0; i--) {\n        // Calculate the min container width for this item if we haven't done so yet\n        if (minContainerWidth[i] === undefined) {\n          const itemOffsetEnd = rtl ? containerWidth - items[i].offsetLeft : items[i].offsetLeft + items[i].offsetWidth;\n\n          // If the item after this one is pinned, reserve space for it\n          if (i + 1 < items.length && i + 1 === pinnedIndex) {\n            // Use distance between the end of the previous item and this one (rather than the\n            // pinned item's offsetWidth), to account for any margin between the items.\n            extraWidth = minContainerWidth[i + 1] - itemOffsetEnd;\n          }\n\n          // Reserve space for the menu button after the first item was added to the overflow\n          if (i === items.length - 2) {\n            extraWidth += menuButton.offsetWidth;\n          }\n\n          minContainerWidth[i] = itemOffsetEnd + extraWidth;\n        }\n\n        if (containerWidth > minContainerWidth[i]) {\n          setOverflowIndex(i + 1);\n          return;\n        }\n      }\n\n      // If we got here, nothing fits outside the overflow\n      setOverflowIndex(0);\n    };\n\n    let prevOverflowIndex = items.length;\n    const setOverflowIndex = (overflowIndex: number) => {\n      if (prevOverflowIndex !== overflowIndex) {\n        prevOverflowIndex = overflowIndex;\n        onOverflowItemsChanged(\n          overflowIndex,\n          items.map((ele, index) => ({\n            ele,\n            isOverflowing: index >= overflowIndex && index !== pinnedIndex,\n          })),\n        );\n      }\n    };\n\n    let cancelAnimationFrame: (() => void) | undefined = undefined;\n\n    // If the container width is already known from a previous render, update the overflow with its width.\n    // Do this in an animation frame to avoid forcing layout to happen early.\n    if (containerWidthRef.current !== undefined) {\n      const win = getWindow(container);\n      if (win) {\n        const animationFrameId = win.requestAnimationFrame(updateOverflowRef.current);\n        cancelAnimationFrame = () => win.cancelAnimationFrame(animationFrameId);\n      }\n    }\n\n    return () => {\n      if (cancelAnimationFrame) {\n        cancelAnimationFrame();\n      }\n\n      // On cleanup, need to remove all items from the overflow\n      // so they don't have stale properties on the next render\n      setOverflowIndex(items.length);\n      updateOverflowRef.current = undefined;\n    };\n  });\n\n  return { menuButtonRef };\n};\n"]},"metadata":{},"sourceType":"module"}