{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { getRTL, classNamesFunction } from '@fluentui/utilities';\nimport { FocusZone } from '../../FocusZone';\nimport { getDateRangeArray, getDayGrid, getBoundedDateRange, isRestrictedDate, DAYS_IN_WEEK, compareDates, DateRangeType } from '@fluentui/date-time-utilities';\nimport { usePrevious, useId } from '@fluentui/react-hooks';\nimport { CalendarMonthHeaderRow } from './CalendarMonthHeaderRow';\nimport { CalendarGridRow } from './CalendarGridRow';\nvar getClassNames = classNamesFunction();\n\nfunction useDayRefs() {\n  var daysRef = React.useRef({});\n\n  var getSetRefCallback = function getSetRefCallback(dayKey) {\n    return function (element) {\n      if (element === null) {\n        delete daysRef.current[dayKey];\n      } else {\n        daysRef.current[dayKey] = element;\n      }\n    };\n  };\n\n  return [daysRef, getSetRefCallback];\n}\n\nfunction useWeeks(props, onSelectDate, getSetRefCallback) {\n  /**\n   * Initial parsing of the given props to generate IDayInfo two dimensional array, which contains a representation\n   * of every day in the grid. Convenient for helping with conversions between day refs and Date objects in callbacks.\n   */\n  var weeks = React.useMemo(function () {\n    var _a;\n\n    var weeksGrid = getDayGrid(props);\n    var firstVisibleDay = weeksGrid[1][0].originalDate;\n    var lastVisibleDay = weeksGrid[weeksGrid.length - 1][6].originalDate;\n    var markedDays = ((_a = props.getMarkedDays) === null || _a === void 0 ? void 0 : _a.call(props, firstVisibleDay, lastVisibleDay)) || [];\n    /**\n     * Weeks is a 2D array. Weeks[0] contains the last week of the prior range,\n     * Weeks[weeks.length - 1] contains first week of next range. These are for transition states.\n     *\n     * Weeks[1... weeks.length - 2] contains the actual visible data\n     */\n\n    var returnValue = [];\n\n    for (var weekIndex = 0; weekIndex < weeksGrid.length; weekIndex++) {\n      var week = [];\n\n      var _loop_1 = function _loop_1(dayIndex) {\n        var day = weeksGrid[weekIndex][dayIndex];\n\n        var dayInfo = __assign(__assign({\n          onSelected: function onSelected() {\n            return onSelectDate(day.originalDate);\n          },\n          setRef: getSetRefCallback(day.key)\n        }, day), {\n          isMarked: day.isMarked || (markedDays === null || markedDays === void 0 ? void 0 : markedDays.some(function (markedDay) {\n            return compareDates(day.originalDate, markedDay);\n          }))\n        });\n\n        week.push(dayInfo);\n      };\n\n      for (var dayIndex = 0; dayIndex < DAYS_IN_WEEK; dayIndex++) {\n        _loop_1(dayIndex);\n      }\n\n      returnValue.push(week);\n    }\n\n    return returnValue; // TODO: this is missing deps on getSetRefCallback and onSelectDate (and depending on the entire\n    // props object may not be a good idea due to likely frequent mutation). It would be easy to\n    // fix getSetRefCallback to not mutate every render, but onSelectDate is passed down from\n    // Calendar and trying to fix it requires a huge cascade of changes.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [props]);\n  return weeks;\n}\n/**\n * Hook to determine whether to animate the CalendarDayGrid forwards or backwards\n * @returns true if the grid should animate backwards; false otherwise\n */\n\n\nfunction useAnimateBackwards(weeks) {\n  var previousNavigatedDate = usePrevious(weeks[0][0].originalDate);\n\n  if (!previousNavigatedDate || previousNavigatedDate.getTime() === weeks[0][0].originalDate.getTime()) {\n    return undefined;\n  } else if (previousNavigatedDate <= weeks[0][0].originalDate) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nfunction useWeekCornerStyles(props) {\n  /**\n   *\n   * Section for setting the rounded corner styles on individual day cells. Individual day cells need different\n   * corners to be rounded depending on which date range type and where the cell is located in the current grid.\n   * If we just round all of the corners, there isn't a good overlap and we get gaps between contiguous day boxes\n   * in Edge browser.\n   *\n   */\n  var getWeekCornerStyles = function getWeekCornerStyles(classNames, initialWeeks) {\n    var weekCornersStyled = {};\n    /* need to handle setting all of the corners on arbitrarily shaped blobs\n          __\n       __|A |\n      |B |C |__\n      |D |E |F |\n           in this case, A needs top left rounded, top right rounded\n      B needs top left rounded\n      C doesn't need any rounding\n      D needs bottom left rounded\n      E doesn't need any rounding\n      F needs top right rounding\n    */\n    // cut off the animation transition weeks\n\n    var weeks = initialWeeks.slice(1, initialWeeks.length - 1); // if there's an item above, lose both top corners. Item below, lose both bottom corners, etc.\n\n    weeks.forEach(function (week, weekIndex) {\n      week.forEach(function (day, dayIndex) {\n        var above = weeks[weekIndex - 1] && weeks[weekIndex - 1][dayIndex] && isInSameHoverRange(weeks[weekIndex - 1][dayIndex].originalDate, day.originalDate, weeks[weekIndex - 1][dayIndex].isSelected, day.isSelected);\n        var below = weeks[weekIndex + 1] && weeks[weekIndex + 1][dayIndex] && isInSameHoverRange(weeks[weekIndex + 1][dayIndex].originalDate, day.originalDate, weeks[weekIndex + 1][dayIndex].isSelected, day.isSelected);\n        var left = weeks[weekIndex][dayIndex - 1] && isInSameHoverRange(weeks[weekIndex][dayIndex - 1].originalDate, day.originalDate, weeks[weekIndex][dayIndex - 1].isSelected, day.isSelected);\n        var right = weeks[weekIndex][dayIndex + 1] && isInSameHoverRange(weeks[weekIndex][dayIndex + 1].originalDate, day.originalDate, weeks[weekIndex][dayIndex + 1].isSelected, day.isSelected);\n        var style = [];\n        style.push(calculateRoundedStyles(classNames, above, below, left, right));\n        style.push(calculateBorderStyles(classNames, above, below, left, right));\n        weekCornersStyled[weekIndex + '_' + dayIndex] = style.join(' ');\n      });\n    });\n    return weekCornersStyled;\n  };\n\n  var calculateRoundedStyles = function calculateRoundedStyles(classNames, above, below, left, right) {\n    var style = [];\n    var roundedTopLeft = !above && !left;\n    var roundedTopRight = !above && !right;\n    var roundedBottomLeft = !below && !left;\n    var roundedBottomRight = !below && !right;\n\n    if (roundedTopLeft) {\n      style.push(getRTL() ? classNames.topRightCornerDate : classNames.topLeftCornerDate);\n    }\n\n    if (roundedTopRight) {\n      style.push(getRTL() ? classNames.topLeftCornerDate : classNames.topRightCornerDate);\n    }\n\n    if (roundedBottomLeft) {\n      style.push(getRTL() ? classNames.bottomRightCornerDate : classNames.bottomLeftCornerDate);\n    }\n\n    if (roundedBottomRight) {\n      style.push(getRTL() ? classNames.bottomLeftCornerDate : classNames.bottomRightCornerDate);\n    }\n\n    return style.join(' ');\n  };\n\n  var calculateBorderStyles = function calculateBorderStyles(classNames, above, below, left, right) {\n    var style = [];\n\n    if (!above) {\n      style.push(classNames.datesAbove);\n    }\n\n    if (!below) {\n      style.push(classNames.datesBelow);\n    }\n\n    if (!left) {\n      style.push(getRTL() ? classNames.datesRight : classNames.datesLeft);\n    }\n\n    if (!right) {\n      style.push(getRTL() ? classNames.datesLeft : classNames.datesRight);\n    }\n\n    return style.join(' ');\n  };\n\n  var isInSameHoverRange = function isInSameHoverRange(date1, date2, date1Selected, date2Selected) {\n    var dateRangeType = props.dateRangeType,\n        firstDayOfWeek = props.firstDayOfWeek,\n        workWeekDays = props.workWeekDays; // The hover state looks weird with non-contiguous days in work week view. In work week, show week hover state\n\n    var dateRangeHoverType = dateRangeType === DateRangeType.WorkWeek ? DateRangeType.Week : dateRangeType; // we do not pass daysToSelectInDayView because we handle setting those styles dyanamically in onMouseOver\n\n    var dateRange = getDateRangeArray(date1, dateRangeHoverType, firstDayOfWeek, workWeekDays);\n\n    if (date1Selected !== date2Selected) {\n      // if one is selected and the other is not, they can't be in the same range\n      return false;\n    } else if (date1Selected && date2Selected) {\n      // if they're both selected at the same time they must be in the same range\n      return true;\n    } // otherwise, both must be unselected, so check the dateRange\n\n\n    return dateRange.filter(function (date) {\n      return date.getTime() === date2.getTime();\n    }).length > 0;\n  };\n\n  return [getWeekCornerStyles, calculateRoundedStyles];\n}\n\nexport var CalendarDayGridBase = function CalendarDayGridBase(props) {\n  var navigatedDayRef = React.useRef(null);\n  var activeDescendantId = useId();\n\n  var onSelectDate = function onSelectDate(selectedDate) {\n    var _a, _b;\n\n    var firstDayOfWeek = props.firstDayOfWeek,\n        minDate = props.minDate,\n        maxDate = props.maxDate,\n        workWeekDays = props.workWeekDays,\n        daysToSelectInDayView = props.daysToSelectInDayView,\n        restrictedDates = props.restrictedDates;\n    var restrictedDatesOptions = {\n      minDate: minDate,\n      maxDate: maxDate,\n      restrictedDates: restrictedDates\n    };\n    var dateRange = getDateRangeArray(selectedDate, dateRangeType, firstDayOfWeek, workWeekDays, daysToSelectInDayView);\n    dateRange = getBoundedDateRange(dateRange, minDate, maxDate);\n    dateRange = dateRange.filter(function (d) {\n      return !isRestrictedDate(d, restrictedDatesOptions);\n    });\n    (_a = props.onSelectDate) === null || _a === void 0 ? void 0 : _a.call(props, selectedDate, dateRange);\n    (_b = props.onNavigateDate) === null || _b === void 0 ? void 0 : _b.call(props, selectedDate, true);\n  };\n\n  var _a = useDayRefs(),\n      daysRef = _a[0],\n      getSetRefCallback = _a[1];\n\n  var weeks = useWeeks(props, onSelectDate, getSetRefCallback);\n  var animateBackwards = useAnimateBackwards(weeks);\n\n  var _b = useWeekCornerStyles(props),\n      getWeekCornerStyles = _b[0],\n      calculateRoundedStyles = _b[1];\n\n  React.useImperativeHandle(props.componentRef, function () {\n    return {\n      focus: function focus() {\n        var _a, _b;\n\n        (_b = (_a = navigatedDayRef.current) === null || _a === void 0 ? void 0 : _a.focus) === null || _b === void 0 ? void 0 : _b.call(_a);\n      }\n    };\n  }, []);\n  /**\n   *\n   * Section for setting hover/pressed styles. Because we want arbitrary blobs of days to be selectable, to support\n   * highlighting every day in the month for month view, css :hover style isn't enough, so we need mouse callbacks\n   * to set classnames on all relevant child refs to apply the styling\n   *\n   */\n\n  var getDayInfosInRangeOfDay = function getDayInfosInRangeOfDay(dayToCompare) {\n    // The hover state looks weird with non-contiguous days in work week view. In work week, show week hover state\n    var dateRangeHoverType = getDateRangeTypeToUse(props.dateRangeType, props.workWeekDays); // gets all the dates for the given date range type that are in the same date range as the given day\n\n    var dateRange = getDateRangeArray(dayToCompare.originalDate, dateRangeHoverType, props.firstDayOfWeek, props.workWeekDays, props.daysToSelectInDayView).map(function (date) {\n      return date.getTime();\n    }); // gets all the day refs for the given dates\n\n    var dayInfosInRange = weeks.reduce(function (accumulatedValue, currentWeek) {\n      return accumulatedValue.concat(currentWeek.filter(function (weekDay) {\n        return dateRange.indexOf(weekDay.originalDate.getTime()) !== -1;\n      }));\n    }, []);\n    return dayInfosInRange;\n  };\n\n  var getRefsFromDayInfos = function getRefsFromDayInfos(dayInfosInRange) {\n    var dayRefs = [];\n    dayRefs = dayInfosInRange.map(function (dayInfo) {\n      return daysRef.current[dayInfo.key];\n    });\n    return dayRefs;\n  };\n\n  var styles = props.styles,\n      theme = props.theme,\n      className = props.className,\n      dateRangeType = props.dateRangeType,\n      showWeekNumbers = props.showWeekNumbers,\n      labelledBy = props.labelledBy,\n      lightenDaysOutsideNavigatedMonth = props.lightenDaysOutsideNavigatedMonth,\n      animationDirection = props.animationDirection;\n  var classNames = getClassNames(styles, {\n    theme: theme,\n    className: className,\n    dateRangeType: dateRangeType,\n    showWeekNumbers: showWeekNumbers,\n    lightenDaysOutsideNavigatedMonth: lightenDaysOutsideNavigatedMonth === undefined ? true : lightenDaysOutsideNavigatedMonth,\n    animationDirection: animationDirection,\n    animateBackwards: animateBackwards\n  }); // When the month is highlighted get the corner dates so that styles can be added to them\n\n  var weekCorners = getWeekCornerStyles(classNames, weeks);\n  var partialWeekProps = {\n    weeks: weeks,\n    navigatedDayRef: navigatedDayRef,\n    calculateRoundedStyles: calculateRoundedStyles,\n    activeDescendantId: activeDescendantId,\n    classNames: classNames,\n    weekCorners: weekCorners,\n    getDayInfosInRangeOfDay: getDayInfosInRangeOfDay,\n    getRefsFromDayInfos: getRefsFromDayInfos\n  };\n  return React.createElement(FocusZone, {\n    className: classNames.wrapper\n  }, React.createElement(\"table\", {\n    className: classNames.table,\n    \"aria-multiselectable\": \"false\",\n    \"aria-labelledby\": labelledBy,\n    \"aria-activedescendant\": activeDescendantId,\n    role: \"grid\"\n  }, React.createElement(\"tbody\", null, React.createElement(CalendarMonthHeaderRow, __assign({}, props, {\n    classNames: classNames,\n    weeks: weeks\n  })), React.createElement(CalendarGridRow, __assign({}, props, partialWeekProps, {\n    week: weeks[0],\n    weekIndex: -1,\n    rowClassName: classNames.firstTransitionWeek,\n    ariaRole: \"presentation\",\n    ariaHidden: true\n  })), weeks.slice(1, weeks.length - 1).map(function (week, weekIndex) {\n    return React.createElement(CalendarGridRow, __assign({}, props, partialWeekProps, {\n      key: weekIndex,\n      week: week,\n      weekIndex: weekIndex,\n      rowClassName: classNames.weekRow\n    }));\n  }), React.createElement(CalendarGridRow, __assign({}, props, partialWeekProps, {\n    week: weeks[weeks.length - 1],\n    weekIndex: -2,\n    rowClassName: classNames.lastTransitionWeek,\n    ariaRole: \"presentation\",\n    ariaHidden: true\n  })))));\n};\nCalendarDayGridBase.displayName = 'CalendarDayGridBase';\n/**\n * When given work week, if the days are non-contiguous, the hover states look really weird. So for non-contiguous\n * work weeks, we'll just show week view instead.\n */\n\nfunction getDateRangeTypeToUse(dateRangeType, workWeekDays) {\n  if (workWeekDays && dateRangeType === DateRangeType.WorkWeek) {\n    var sortedWWDays = workWeekDays.slice().sort();\n    var isContiguous = true;\n\n    for (var i = 1; i < sortedWWDays.length; i++) {\n      if (sortedWWDays[i] !== sortedWWDays[i - 1] + 1) {\n        isContiguous = false;\n        break;\n      }\n    }\n\n    if (!isContiguous || workWeekDays.length === 0) {\n      return DateRangeType.Week;\n    }\n  }\n\n  return dateRangeType;\n}","map":{"version":3,"mappings":"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","names":["React","getRTL","classNamesFunction","FocusZone","getDateRangeArray","getDayGrid","getBoundedDateRange","isRestrictedDate","DAYS_IN_WEEK","compareDates","DateRangeType","usePrevious","useId","CalendarMonthHeaderRow","CalendarGridRow","getClassNames","useDayRefs","daysRef","useRef","getSetRefCallback","dayKey","element","current","useWeeks","props","onSelectDate","weeks","useMemo","weeksGrid","firstVisibleDay","originalDate","lastVisibleDay","length","markedDays","getMarkedDays","_a","returnValue","weekIndex","week","dayIndex","day","dayInfo","onSelected","setRef","key","isMarked","some","markedDay","push","useAnimateBackwards","previousNavigatedDate","getTime","undefined","useWeekCornerStyles","getWeekCornerStyles","classNames","initialWeeks","weekCornersStyled","slice","forEach","above","isInSameHoverRange","isSelected","below","left","right","style","calculateRoundedStyles","calculateBorderStyles","join","roundedTopLeft","roundedTopRight","roundedBottomLeft","roundedBottomRight","topRightCornerDate","topLeftCornerDate","bottomRightCornerDate","bottomLeftCornerDate","datesAbove","datesBelow","datesRight","datesLeft","date1","date2","date1Selected","date2Selected","firstDayOfWeek","workWeekDays","dateRangeHoverType","dateRangeType","WorkWeek","Week","dateRange","filter","date","CalendarDayGridBase","navigatedDayRef","activeDescendantId","selectedDate","minDate","maxDate","daysToSelectInDayView","restrictedDates","restrictedDatesOptions","d","onNavigateDate","_b","animateBackwards","useImperativeHandle","componentRef","focus","getDayInfosInRangeOfDay","dayToCompare","getDateRangeTypeToUse","map","dayInfosInRange","reduce","accumulatedValue","currentWeek","concat","weekDay","indexOf","getRefsFromDayInfos","dayRefs","theme","className","showWeekNumbers","labelledBy","lightenDaysOutsideNavigatedMonth","animationDirection","styles","weekCorners","partialWeekProps","wrapper","table","role","__assign","rowClassName","firstTransitionWeek","ariaRole","ariaHidden","weekRow","lastTransitionWeek","displayName","sortedWWDays","sort","isContiguous","i"],"sources":["/home/runner/work/Reaction/Reaction/employee-info/node_modules/@fluentui/react/lib/components/src/components/CalendarDayGrid/CalendarDayGrid.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport { getRTL, classNamesFunction } from '@fluentui/utilities';\nimport { FocusZone } from '../../FocusZone';\nimport {\n  getDateRangeArray,\n  getDayGrid,\n  getBoundedDateRange,\n  isRestrictedDate,\n  DAYS_IN_WEEK,\n  compareDates,\n  DateRangeType,\n  DayOfWeek,\n} from '@fluentui/date-time-utilities';\nimport { usePrevious, useId } from '@fluentui/react-hooks';\nimport { CalendarMonthHeaderRow } from './CalendarMonthHeaderRow';\nimport { CalendarGridRow } from './CalendarGridRow';\nimport type { IDay } from '@fluentui/date-time-utilities';\nimport type {\n  ICalendarDayGridProps,\n  ICalendarDayGridStyleProps,\n  ICalendarDayGridStyles,\n} from './CalendarDayGrid.types';\nimport type { IProcessedStyleSet } from '@fluentui/style-utilities';\n\nconst getClassNames = classNamesFunction<ICalendarDayGridStyleProps, ICalendarDayGridStyles>();\n\nexport interface IWeekCorners {\n  [key: string]: string;\n}\n\nexport interface IDayInfo extends IDay {\n  onSelected: () => void;\n  setRef(element: HTMLElement | null): void;\n}\n\nfunction useDayRefs() {\n  const daysRef = React.useRef<Record<string, HTMLElement>>({});\n\n  const getSetRefCallback = (dayKey: string) => (element: HTMLElement | null) => {\n    if (element === null) {\n      delete daysRef.current[dayKey];\n    } else {\n      daysRef.current[dayKey] = element;\n    }\n  };\n\n  return [daysRef, getSetRefCallback] as const;\n}\n\nfunction useWeeks(\n  props: ICalendarDayGridProps,\n  onSelectDate: (date: Date) => void,\n  getSetRefCallback: (dayKey: string) => (element: HTMLElement | null) => void,\n): IDayInfo[][] {\n  /**\n   * Initial parsing of the given props to generate IDayInfo two dimensional array, which contains a representation\n   * of every day in the grid. Convenient for helping with conversions between day refs and Date objects in callbacks.\n   */\n  const weeks = React.useMemo((): IDayInfo[][] => {\n    const weeksGrid = getDayGrid(props);\n\n    const firstVisibleDay = weeksGrid[1][0].originalDate;\n    const lastVisibleDay = weeksGrid[weeksGrid.length - 1][6].originalDate;\n    const markedDays = props.getMarkedDays?.(firstVisibleDay, lastVisibleDay) || [];\n\n    /**\n     * Weeks is a 2D array. Weeks[0] contains the last week of the prior range,\n     * Weeks[weeks.length - 1] contains first week of next range. These are for transition states.\n     *\n     * Weeks[1... weeks.length - 2] contains the actual visible data\n     */\n    const returnValue: IDayInfo[][] = [];\n\n    for (let weekIndex = 0; weekIndex < weeksGrid.length; weekIndex++) {\n      const week: IDayInfo[] = [];\n      for (let dayIndex = 0; dayIndex < DAYS_IN_WEEK; dayIndex++) {\n        const day = weeksGrid[weekIndex][dayIndex];\n        const dayInfo: IDayInfo = {\n          onSelected: () => onSelectDate(day.originalDate),\n          setRef: getSetRefCallback(day.key),\n          ...day,\n          isMarked: day.isMarked || markedDays?.some(markedDay => compareDates(day.originalDate, markedDay)),\n        };\n\n        week.push(dayInfo);\n      }\n      returnValue.push(week);\n    }\n\n    return returnValue;\n    // TODO: this is missing deps on getSetRefCallback and onSelectDate (and depending on the entire\n    // props object may not be a good idea due to likely frequent mutation). It would be easy to\n    // fix getSetRefCallback to not mutate every render, but onSelectDate is passed down from\n    // Calendar and trying to fix it requires a huge cascade of changes.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [props]);\n\n  return weeks;\n}\n\n/**\n * Hook to determine whether to animate the CalendarDayGrid forwards or backwards\n * @returns true if the grid should animate backwards; false otherwise\n */\nfunction useAnimateBackwards(weeks: IDayInfo[][]): boolean | undefined {\n  const previousNavigatedDate = usePrevious(weeks[0][0].originalDate);\n\n  if (!previousNavigatedDate || previousNavigatedDate.getTime() === weeks[0][0].originalDate.getTime()) {\n    return undefined;\n  } else if (previousNavigatedDate <= weeks[0][0].originalDate) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nfunction useWeekCornerStyles(props: ICalendarDayGridProps) {\n  /**\n   *\n   * Section for setting the rounded corner styles on individual day cells. Individual day cells need different\n   * corners to be rounded depending on which date range type and where the cell is located in the current grid.\n   * If we just round all of the corners, there isn't a good overlap and we get gaps between contiguous day boxes\n   * in Edge browser.\n   *\n   */\n  const getWeekCornerStyles = (\n    classNames: IProcessedStyleSet<ICalendarDayGridStyles>,\n    initialWeeks: IDayInfo[][],\n  ): IWeekCorners => {\n    const weekCornersStyled: { [key: string]: string } = {};\n    /* need to handle setting all of the corners on arbitrarily shaped blobs\n          __\n       __|A |\n      |B |C |__\n      |D |E |F |\n\n      in this case, A needs top left rounded, top right rounded\n      B needs top left rounded\n      C doesn't need any rounding\n      D needs bottom left rounded\n      E doesn't need any rounding\n      F needs top right rounding\n    */\n\n    // cut off the animation transition weeks\n    const weeks = initialWeeks.slice(1, initialWeeks.length - 1);\n\n    // if there's an item above, lose both top corners. Item below, lose both bottom corners, etc.\n    weeks.forEach((week: IDayInfo[], weekIndex: number) => {\n      week.forEach((day: IDayInfo, dayIndex: number) => {\n        const above =\n          weeks[weekIndex - 1] &&\n          weeks[weekIndex - 1][dayIndex] &&\n          isInSameHoverRange(\n            weeks[weekIndex - 1][dayIndex].originalDate,\n            day.originalDate,\n            weeks[weekIndex - 1][dayIndex].isSelected,\n            day.isSelected,\n          );\n        const below =\n          weeks[weekIndex + 1] &&\n          weeks[weekIndex + 1][dayIndex] &&\n          isInSameHoverRange(\n            weeks[weekIndex + 1][dayIndex].originalDate,\n            day.originalDate,\n            weeks[weekIndex + 1][dayIndex].isSelected,\n            day.isSelected,\n          );\n        const left =\n          weeks[weekIndex][dayIndex - 1] &&\n          isInSameHoverRange(\n            weeks[weekIndex][dayIndex - 1].originalDate,\n            day.originalDate,\n            weeks[weekIndex][dayIndex - 1].isSelected,\n            day.isSelected,\n          );\n        const right =\n          weeks[weekIndex][dayIndex + 1] &&\n          isInSameHoverRange(\n            weeks[weekIndex][dayIndex + 1].originalDate,\n            day.originalDate,\n            weeks[weekIndex][dayIndex + 1].isSelected,\n            day.isSelected,\n          );\n\n        const style = [];\n        style.push(calculateRoundedStyles(classNames, above, below, left, right));\n        style.push(calculateBorderStyles(classNames, above, below, left, right));\n\n        weekCornersStyled[weekIndex + '_' + dayIndex] = style.join(' ');\n      });\n    });\n\n    return weekCornersStyled;\n  };\n\n  const calculateRoundedStyles = (\n    classNames: IProcessedStyleSet<ICalendarDayGridStyles>,\n    above: boolean,\n    below: boolean,\n    left: boolean,\n    right: boolean,\n  ): string => {\n    const style = [];\n    const roundedTopLeft = !above && !left;\n    const roundedTopRight = !above && !right;\n    const roundedBottomLeft = !below && !left;\n    const roundedBottomRight = !below && !right;\n\n    if (roundedTopLeft) {\n      style.push(getRTL() ? classNames.topRightCornerDate : classNames.topLeftCornerDate);\n    }\n    if (roundedTopRight) {\n      style.push(getRTL() ? classNames.topLeftCornerDate : classNames.topRightCornerDate);\n    }\n    if (roundedBottomLeft) {\n      style.push(getRTL() ? classNames.bottomRightCornerDate : classNames.bottomLeftCornerDate);\n    }\n    if (roundedBottomRight) {\n      style.push(getRTL() ? classNames.bottomLeftCornerDate : classNames.bottomRightCornerDate);\n    }\n\n    return style.join(' ');\n  };\n\n  const calculateBorderStyles = (\n    classNames: IProcessedStyleSet<ICalendarDayGridStyles>,\n    above: boolean,\n    below: boolean,\n    left: boolean,\n    right: boolean,\n  ): string => {\n    const style = [];\n\n    if (!above) {\n      style.push(classNames.datesAbove);\n    }\n    if (!below) {\n      style.push(classNames.datesBelow);\n    }\n    if (!left) {\n      style.push(getRTL() ? classNames.datesRight : classNames.datesLeft);\n    }\n    if (!right) {\n      style.push(getRTL() ? classNames.datesLeft : classNames.datesRight);\n    }\n\n    return style.join(' ');\n  };\n\n  const isInSameHoverRange = (date1: Date, date2: Date, date1Selected: boolean, date2Selected: boolean): boolean => {\n    const { dateRangeType, firstDayOfWeek, workWeekDays } = props;\n\n    // The hover state looks weird with non-contiguous days in work week view. In work week, show week hover state\n    const dateRangeHoverType = dateRangeType === DateRangeType.WorkWeek ? DateRangeType.Week : dateRangeType;\n\n    // we do not pass daysToSelectInDayView because we handle setting those styles dyanamically in onMouseOver\n    const dateRange = getDateRangeArray(date1, dateRangeHoverType, firstDayOfWeek, workWeekDays);\n\n    if (date1Selected !== date2Selected) {\n      // if one is selected and the other is not, they can't be in the same range\n      return false;\n    } else if (date1Selected && date2Selected) {\n      // if they're both selected at the same time they must be in the same range\n      return true;\n    }\n\n    // otherwise, both must be unselected, so check the dateRange\n    return dateRange.filter((date: Date) => date.getTime() === date2.getTime()).length > 0;\n  };\n\n  return [getWeekCornerStyles, calculateRoundedStyles] as const;\n}\n\nexport const CalendarDayGridBase: React.FunctionComponent<ICalendarDayGridProps> = props => {\n  const navigatedDayRef = React.useRef<HTMLTableCellElement>(null) as React.MutableRefObject<HTMLTableCellElement>;\n\n  const activeDescendantId = useId();\n\n  const onSelectDate = (selectedDate: Date): void => {\n    const { firstDayOfWeek, minDate, maxDate, workWeekDays, daysToSelectInDayView, restrictedDates } = props;\n    const restrictedDatesOptions = { minDate, maxDate, restrictedDates };\n\n    let dateRange = getDateRangeArray(selectedDate, dateRangeType, firstDayOfWeek, workWeekDays, daysToSelectInDayView);\n    dateRange = getBoundedDateRange(dateRange, minDate, maxDate);\n\n    dateRange = dateRange.filter((d: Date) => {\n      return !isRestrictedDate(d, restrictedDatesOptions);\n    });\n\n    props.onSelectDate?.(selectedDate, dateRange);\n    props.onNavigateDate?.(selectedDate, true);\n  };\n\n  const [daysRef, getSetRefCallback] = useDayRefs();\n\n  const weeks = useWeeks(props, onSelectDate, getSetRefCallback);\n  const animateBackwards = useAnimateBackwards(weeks);\n  const [getWeekCornerStyles, calculateRoundedStyles] = useWeekCornerStyles(props);\n\n  React.useImperativeHandle(\n    props.componentRef,\n    () => ({\n      focus() {\n        navigatedDayRef.current?.focus?.();\n      },\n    }),\n    [],\n  );\n\n  /**\n   *\n   * Section for setting hover/pressed styles. Because we want arbitrary blobs of days to be selectable, to support\n   * highlighting every day in the month for month view, css :hover style isn't enough, so we need mouse callbacks\n   * to set classnames on all relevant child refs to apply the styling\n   *\n   */\n  const getDayInfosInRangeOfDay = (dayToCompare: IDayInfo): IDayInfo[] => {\n    // The hover state looks weird with non-contiguous days in work week view. In work week, show week hover state\n    const dateRangeHoverType = getDateRangeTypeToUse(props.dateRangeType, props.workWeekDays);\n\n    // gets all the dates for the given date range type that are in the same date range as the given day\n    const dateRange = getDateRangeArray(\n      dayToCompare.originalDate,\n      dateRangeHoverType,\n      props.firstDayOfWeek,\n      props.workWeekDays,\n      props.daysToSelectInDayView,\n    ).map((date: Date) => date.getTime());\n\n    // gets all the day refs for the given dates\n    const dayInfosInRange = weeks.reduce((accumulatedValue: IDayInfo[], currentWeek: IDayInfo[]) => {\n      return accumulatedValue.concat(\n        currentWeek.filter((weekDay: IDayInfo) => dateRange.indexOf(weekDay.originalDate.getTime()) !== -1),\n      );\n    }, []);\n\n    return dayInfosInRange;\n  };\n\n  const getRefsFromDayInfos = (dayInfosInRange: IDayInfo[]): (HTMLElement | null)[] => {\n    let dayRefs: (HTMLElement | null)[] = [];\n    dayRefs = dayInfosInRange.map((dayInfo: IDayInfo) => daysRef.current[dayInfo.key]);\n\n    return dayRefs;\n  };\n\n  const {\n    styles,\n    theme,\n    className,\n    dateRangeType,\n    showWeekNumbers,\n    labelledBy,\n    lightenDaysOutsideNavigatedMonth,\n    animationDirection,\n  } = props;\n\n  const classNames = getClassNames(styles, {\n    theme: theme!,\n    className: className,\n    dateRangeType: dateRangeType,\n    showWeekNumbers: showWeekNumbers,\n    lightenDaysOutsideNavigatedMonth:\n      lightenDaysOutsideNavigatedMonth === undefined ? true : lightenDaysOutsideNavigatedMonth,\n    animationDirection: animationDirection,\n    animateBackwards: animateBackwards,\n  });\n\n  // When the month is highlighted get the corner dates so that styles can be added to them\n  const weekCorners: IWeekCorners = getWeekCornerStyles(classNames, weeks!);\n  const partialWeekProps = {\n    weeks,\n    navigatedDayRef,\n    calculateRoundedStyles,\n    activeDescendantId,\n    classNames,\n    weekCorners,\n    getDayInfosInRangeOfDay,\n    getRefsFromDayInfos,\n  } as const;\n\n  return (\n    <FocusZone className={classNames.wrapper}>\n      <table\n        className={classNames.table}\n        aria-multiselectable=\"false\"\n        aria-labelledby={labelledBy}\n        aria-activedescendant={activeDescendantId}\n        role=\"grid\"\n      >\n        <tbody>\n          <CalendarMonthHeaderRow {...props} classNames={classNames} weeks={weeks} />\n          <CalendarGridRow\n            {...props}\n            {...partialWeekProps}\n            week={weeks[0]}\n            weekIndex={-1}\n            rowClassName={classNames.firstTransitionWeek}\n            ariaRole=\"presentation\"\n            ariaHidden={true}\n          />\n          {weeks!.slice(1, weeks!.length - 1).map((week: IDayInfo[], weekIndex: number) => (\n            <CalendarGridRow\n              {...props}\n              {...partialWeekProps}\n              key={weekIndex}\n              week={week}\n              weekIndex={weekIndex}\n              rowClassName={classNames.weekRow}\n            />\n          ))}\n          <CalendarGridRow\n            {...props}\n            {...partialWeekProps}\n            week={weeks![weeks!.length - 1]}\n            weekIndex={-2}\n            rowClassName={classNames.lastTransitionWeek}\n            ariaRole=\"presentation\"\n            ariaHidden={true}\n          />\n        </tbody>\n      </table>\n    </FocusZone>\n  );\n};\nCalendarDayGridBase.displayName = 'CalendarDayGridBase';\n\n/**\n * When given work week, if the days are non-contiguous, the hover states look really weird. So for non-contiguous\n * work weeks, we'll just show week view instead.\n */\nfunction getDateRangeTypeToUse(dateRangeType: DateRangeType, workWeekDays: DayOfWeek[] | undefined): DateRangeType {\n  if (workWeekDays && dateRangeType === DateRangeType.WorkWeek) {\n    const sortedWWDays = workWeekDays.slice().sort();\n    let isContiguous = true;\n    for (let i = 1; i < sortedWWDays.length; i++) {\n      if (sortedWWDays[i] !== sortedWWDays[i - 1] + 1) {\n        isContiguous = false;\n        break;\n      }\n    }\n\n    if (!isContiguous || workWeekDays.length === 0) {\n      return DateRangeType.Week;\n    }\n  }\n\n  return dateRangeType;\n}\n"]},"metadata":{},"sourceType":"module"}