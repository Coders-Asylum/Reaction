{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, getNativeProps, initializeComponentRef, inputProperties, isIE11, KeyCodes } from '../../Utilities';\nvar SELECTION_FORWARD = 'forward';\nvar SELECTION_BACKWARD = 'backward';\n/**\n * {@docCategory Autofill}\n */\n\nvar Autofill =\n/** @class */\nfunction (_super) {\n  __extends(Autofill, _super);\n\n  function Autofill(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._inputElement = React.createRef();\n    _this._autoFillEnabled = true; // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and languages like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n\n    _this._onCompositionStart = function (ev) {\n      _this.setState({\n        isComposing: true\n      });\n\n      _this._autoFillEnabled = false;\n    }; // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and languages like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n\n\n    _this._onCompositionUpdate = function () {\n      if (isIE11()) {\n        _this._updateValue(_this._getCurrentInputValue(), true);\n      }\n    }; // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and languages like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n\n\n    _this._onCompositionEnd = function (ev) {\n      var inputValue = _this._getCurrentInputValue();\n\n      _this._tryEnableAutofill(inputValue, _this.value, false, true);\n\n      _this.setState({\n        isComposing: false\n      }); // Due to timing, this needs to be async, otherwise no text will be selected.\n\n\n      _this._async.setTimeout(function () {\n        // it's technically possible that the value of isComposing is reset during this timeout,\n        // so explicitly trigger this with composing=true here, since it is supposed to be the\n        // update for composition end\n        _this._updateValue(_this._getCurrentInputValue(), false);\n      }, 0);\n    };\n\n    _this._onClick = function () {\n      if (_this.value && _this.value !== '' && _this._autoFillEnabled) {\n        _this._autoFillEnabled = false;\n      }\n    };\n\n    _this._onKeyDown = function (ev) {\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(ev);\n      } // If the event is actively being composed, then don't alert autofill.\n      // Right now typing does not have isComposing, once that has been fixed any should be removed.\n\n\n      if (!ev.nativeEvent.isComposing) {\n        // eslint-disable-next-line deprecation/deprecation\n        switch (ev.which) {\n          case KeyCodes.backspace:\n            _this._autoFillEnabled = false;\n            break;\n\n          case KeyCodes.left:\n          case KeyCodes.right:\n            if (_this._autoFillEnabled) {\n              _this.setState({\n                inputValue: _this.props.suggestedDisplayValue || ''\n              });\n\n              _this._autoFillEnabled = false;\n            }\n\n            break;\n\n          default:\n            if (!_this._autoFillEnabled) {\n              // eslint-disable-next-line deprecation/deprecation\n              if (_this.props.enableAutofillOnKeyPress.indexOf(ev.which) !== -1) {\n                _this._autoFillEnabled = true;\n              }\n            }\n\n            break;\n        }\n      }\n    };\n\n    _this._onInputChanged = function (ev) {\n      var value = _this._getCurrentInputValue(ev);\n\n      if (!_this.state.isComposing) {\n        _this._tryEnableAutofill(value, _this.value, ev.nativeEvent.isComposing);\n      } // If it is not IE11 and currently composing, update the value\n\n\n      if (!(isIE11() && _this.state.isComposing)) {\n        var nativeEventComposing = ev.nativeEvent.isComposing;\n        var isComposing = nativeEventComposing === undefined ? _this.state.isComposing : nativeEventComposing;\n\n        _this._updateValue(value, isComposing);\n      }\n    };\n\n    _this._onChanged = function () {\n      // Swallow this event, we don't care about it\n      // We must provide it because React PropTypes marks it as required, but onInput serves the correct purpose\n      return;\n    };\n    /**\n     * Updates the current input value as well as getting a new display value.\n     * @param newValue - The new value from the input\n     */\n\n\n    _this._updateValue = function (newValue, composing) {\n      // Only proceed if the value is nonempty and is different from the old value\n      // This is to work around the fact that, in IE 11, inputs with a placeholder fire an onInput event on focus\n      if (!newValue && newValue === _this.value) {\n        return;\n      } // eslint-disable-next-line deprecation/deprecation\n\n\n      var _a = _this.props,\n          onInputChange = _a.onInputChange,\n          onInputValueChange = _a.onInputValueChange;\n\n      if (onInputChange) {\n        newValue = (onInputChange === null || onInputChange === void 0 ? void 0 : onInputChange(newValue, composing)) || '';\n      }\n\n      _this.setState({\n        inputValue: newValue\n      }, function () {\n        return onInputValueChange === null || onInputValueChange === void 0 ? void 0 : onInputValueChange(newValue, composing);\n      });\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this.state = {\n      inputValue: props.defaultVisibleValue || '',\n      isComposing: false\n    };\n    return _this;\n  }\n\n  Autofill.getDerivedStateFromProps = function (props, state) {\n    // eslint-disable-next-line deprecation/deprecation\n    if (props.updateValueInWillReceiveProps) {\n      // eslint-disable-next-line deprecation/deprecation\n      var updatedInputValue = props.updateValueInWillReceiveProps(); // Don't update if we have a null value or the value isn't changing\n      // the value should still update if an empty string is passed in\n\n      if (updatedInputValue !== null && updatedInputValue !== state.inputValue && !state.isComposing) {\n        return __assign(__assign({}, state), {\n          inputValue: updatedInputValue\n        });\n      }\n    }\n\n    return null;\n  };\n\n  Object.defineProperty(Autofill.prototype, \"cursorLocation\", {\n    get: function get() {\n      if (this._inputElement.current) {\n        var inputElement = this._inputElement.current;\n\n        if (inputElement.selectionDirection !== SELECTION_FORWARD) {\n          return inputElement.selectionEnd;\n        } else {\n          return inputElement.selectionStart;\n        }\n      } else {\n        return -1;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"isValueSelected\", {\n    get: function get() {\n      return Boolean(this.inputElement && this.inputElement.selectionStart !== this.inputElement.selectionEnd);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"value\", {\n    get: function get() {\n      return this._getControlledValue() || this.state.inputValue || '';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"selectionStart\", {\n    get: function get() {\n      return this._inputElement.current ? this._inputElement.current.selectionStart : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"selectionEnd\", {\n    get: function get() {\n      return this._inputElement.current ? this._inputElement.current.selectionEnd : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"inputElement\", {\n    get: function get() {\n      return this._inputElement.current;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Autofill.prototype.componentDidUpdate = function (_, _1, cursor) {\n    var _a = this.props,\n        suggestedDisplayValue = _a.suggestedDisplayValue,\n        shouldSelectFullInputValueInComponentDidUpdate = _a.shouldSelectFullInputValueInComponentDidUpdate,\n        preventValueSelection = _a.preventValueSelection;\n    var differenceIndex = 0;\n\n    if (preventValueSelection) {\n      return;\n    }\n\n    if (this._autoFillEnabled && this.value && suggestedDisplayValue && _doesTextStartWith(suggestedDisplayValue, this.value)) {\n      var shouldSelectFullRange = false;\n\n      if (shouldSelectFullInputValueInComponentDidUpdate) {\n        shouldSelectFullRange = shouldSelectFullInputValueInComponentDidUpdate();\n      }\n\n      if (shouldSelectFullRange && this._inputElement.current) {\n        this._inputElement.current.setSelectionRange(0, suggestedDisplayValue.length, SELECTION_BACKWARD);\n      } else {\n        while (differenceIndex < this.value.length && this.value[differenceIndex].toLocaleLowerCase() === suggestedDisplayValue[differenceIndex].toLocaleLowerCase()) {\n          differenceIndex++;\n        }\n\n        if (differenceIndex > 0 && this._inputElement.current) {\n          this._inputElement.current.setSelectionRange(differenceIndex, suggestedDisplayValue.length, SELECTION_BACKWARD);\n        }\n      }\n    } else if (this._inputElement.current) {\n      if (cursor !== null && !this._autoFillEnabled && !this.state.isComposing) {\n        this._inputElement.current.setSelectionRange(cursor.start, cursor.end, cursor.dir);\n      }\n    }\n  };\n\n  Autofill.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n  };\n\n  Autofill.prototype.render = function () {\n    var nativeProps = getNativeProps(this.props, inputProperties);\n\n    var style = __assign(__assign({}, this.props.style), {\n      fontFamily: 'inherit'\n    });\n\n    return React.createElement(\"input\", __assign({\n      autoCapitalize: \"off\",\n      autoComplete: \"off\",\n      \"aria-autocomplete\": 'both'\n    }, nativeProps, {\n      style: style,\n      ref: this._inputElement,\n      value: this._getDisplayValue(),\n      onCompositionStart: this._onCompositionStart,\n      onCompositionUpdate: this._onCompositionUpdate,\n      onCompositionEnd: this._onCompositionEnd,\n      // TODO (Fabric 8?) - switch to calling only onChange. See notes in TextField._onInputChange.\n      onChange: this._onChanged,\n      onInput: this._onInputChanged,\n      onKeyDown: this._onKeyDown,\n      onClick: this.props.onClick ? this.props.onClick : this._onClick,\n      \"data-lpignore\": true\n    }));\n  };\n\n  Autofill.prototype.focus = function () {\n    this._inputElement.current && this._inputElement.current.focus();\n  };\n\n  Autofill.prototype.clear = function () {\n    this._autoFillEnabled = true;\n\n    this._updateValue('', false);\n\n    this._inputElement.current && this._inputElement.current.setSelectionRange(0, 0);\n  };\n\n  Autofill.prototype.getSnapshotBeforeUpdate = function () {\n    var _a, _b;\n\n    var inel = this._inputElement.current;\n\n    if (inel && inel.selectionStart !== this.value.length) {\n      return {\n        start: (_a = inel.selectionStart) !== null && _a !== void 0 ? _a : inel.value.length,\n        end: (_b = inel.selectionEnd) !== null && _b !== void 0 ? _b : inel.value.length,\n        dir: inel.selectionDirection || 'backward' || 'none'\n      };\n    }\n\n    return null;\n  };\n\n  Autofill.prototype._getCurrentInputValue = function (ev) {\n    if (ev && ev.target && ev.target.value) {\n      return ev.target.value;\n    } else if (this.inputElement && this.inputElement.value) {\n      return this.inputElement.value;\n    } else {\n      return '';\n    }\n  };\n  /**\n   * Attempts to enable autofill. Whether or not autofill is enabled depends on the input value,\n   * whether or not any text is selected, and only if the new input value is longer than the old input value.\n   * Autofill should never be set to true if the value is composing. Once compositionEnd is called, then\n   * it should be completed.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent for more information on composition.\n   * @param newValue - new input value\n   * @param oldValue - old input value\n   * @param isComposing - if true then the text is actively being composed and it has not completed.\n   * @param isComposed - if the text is a composed text value.\n   */\n\n\n  Autofill.prototype._tryEnableAutofill = function (newValue, oldValue, isComposing, isComposed) {\n    if (!isComposing && newValue && this._inputElement.current && this._inputElement.current.selectionStart === newValue.length && !this._autoFillEnabled && (newValue.length > oldValue.length || isComposed)) {\n      this._autoFillEnabled = true;\n    }\n  };\n\n  Autofill.prototype._getDisplayValue = function () {\n    if (this._autoFillEnabled) {\n      return _getDisplayValue(this.value, this.props.suggestedDisplayValue);\n    }\n\n    return this.value;\n  };\n\n  Autofill.prototype._getControlledValue = function () {\n    var value = this.props.value;\n\n    if (value === undefined || typeof value === 'string') {\n      return value;\n    } // eslint-disable-next-line no-console\n\n\n    console.warn(\"props.value of Autofill should be a string, but it is \" + value + \" with type of \" + typeof value);\n    return value.toString();\n  };\n\n  Autofill.defaultProps = {\n    enableAutofillOnKeyPress: [KeyCodes.down, KeyCodes.up]\n  };\n  return Autofill;\n}(React.Component);\n\nexport { Autofill };\n/**\n * Returns a string that should be used as the display value.\n * It evaluates this based on whether or not the suggested value starts with the input value\n * and whether or not autofill is enabled.\n * @param inputValue - the value that the input currently has.\n * @param suggestedDisplayValue - the possible full value\n */\n\nfunction _getDisplayValue(inputValue, suggestedDisplayValue) {\n  var displayValue = inputValue;\n\n  if (suggestedDisplayValue && inputValue && _doesTextStartWith(suggestedDisplayValue, displayValue)) {\n    displayValue = suggestedDisplayValue;\n  }\n\n  return displayValue;\n}\n\nfunction _doesTextStartWith(text, startWith) {\n  if (!text || !startWith) {\n    return false;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    for (var _i = 0, _a = [text, startWith]; _i < _a.length; _i++) {\n      var val = _a[_i];\n\n      if (typeof val !== 'string') {\n        throw new Error(Autofill.name + \" received non-string value \\\"\" + val + \"\\\" of type \" + typeof val + \" from either input's value or suggestedDisplayValue\");\n      }\n    }\n  }\n\n  return text.toLocaleLowerCase().indexOf(startWith.toLocaleLowerCase()) === 0;\n}","map":{"version":3,"mappings":"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","names":["React","Async","getNativeProps","initializeComponentRef","inputProperties","isIE11","KeyCodes","SELECTION_FORWARD","SELECTION_BACKWARD","__extends","props","_super","_this","createRef","ev","setState","isComposing","_autoFillEnabled","_updateValue","_getCurrentInputValue","inputValue","_tryEnableAutofill","value","_async","setTimeout","onKeyDown","nativeEvent","which","backspace","left","right","suggestedDisplayValue","enableAutofillOnKeyPress","indexOf","state","nativeEventComposing","undefined","newValue","composing","onInputChange","onInputValueChange","defaultVisibleValue","Autofill","updateValueInWillReceiveProps","updatedInputValue","Object","_inputElement","current","inputElement","selectionDirection","selectionEnd","selectionStart","Boolean","_getControlledValue","_","_1","cursor","shouldSelectFullInputValueInComponentDidUpdate","preventValueSelection","differenceIndex","_doesTextStartWith","shouldSelectFullRange","setSelectionRange","length","toLocaleLowerCase","start","end","dir","dispose","nativeProps","style","fontFamily","autoCapitalize","autoComplete","ref","_getDisplayValue","onCompositionStart","_onCompositionStart","onCompositionUpdate","_onCompositionUpdate","onCompositionEnd","_onCompositionEnd","onChange","_onChanged","onInput","_onInputChanged","_onKeyDown","onClick","_onClick","focus","inel","_a","_b","target","oldValue","isComposed","console","warn","toString","down","up","Component","displayValue","text","startWith","process","env","NODE_ENV","_i","val","Error","name"],"sources":["/home/runner/work/Reaction/Reaction/employee-info/node_modules/@fluentui/react/lib/components/src/components/Autofill/Autofill.tsx"],"sourcesContent":["import * as React from 'react';\nimport { Async, getNativeProps, initializeComponentRef, inputProperties, isIE11, KeyCodes } from '../../Utilities';\nimport type { IAutofill, IAutofillProps } from './Autofill.types';\n\nexport interface IAutofillState {\n  inputValue: string;\n  isComposing: boolean;\n}\n\ninterface ICursorLocation {\n  start: number;\n  end: number;\n  dir: 'forward' | 'backward' | 'none' | undefined;\n}\n\nconst SELECTION_FORWARD = 'forward';\nconst SELECTION_BACKWARD = 'backward';\n\n/**\n * {@docCategory Autofill}\n */\nexport class Autofill extends React.Component<IAutofillProps, IAutofillState> implements IAutofill {\n  public static defaultProps = {\n    enableAutofillOnKeyPress: [KeyCodes.down, KeyCodes.up] as KeyCodes[],\n  };\n\n  private _inputElement = React.createRef<HTMLInputElement>();\n  private _autoFillEnabled = true;\n  private _async: Async;\n\n  public static getDerivedStateFromProps(props: IAutofillProps, state: IAutofillState): IAutofillState | null {\n    // eslint-disable-next-line deprecation/deprecation\n    if (props.updateValueInWillReceiveProps) {\n      // eslint-disable-next-line deprecation/deprecation\n      const updatedInputValue = props.updateValueInWillReceiveProps();\n      // Don't update if we have a null value or the value isn't changing\n      // the value should still update if an empty string is passed in\n      if (updatedInputValue !== null && updatedInputValue !== state.inputValue && !state.isComposing) {\n        return { ...state, inputValue: updatedInputValue };\n      }\n    }\n    return null;\n  }\n\n  constructor(props: IAutofillProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n\n    this.state = {\n      inputValue: props.defaultVisibleValue || '',\n      isComposing: false,\n    };\n  }\n\n  public get cursorLocation(): number | null {\n    if (this._inputElement.current) {\n      const inputElement = this._inputElement.current;\n      if (inputElement.selectionDirection !== SELECTION_FORWARD) {\n        return inputElement.selectionEnd;\n      } else {\n        return inputElement.selectionStart;\n      }\n    } else {\n      return -1;\n    }\n  }\n\n  public get isValueSelected(): boolean {\n    return Boolean(this.inputElement && this.inputElement.selectionStart !== this.inputElement.selectionEnd);\n  }\n\n  public get value(): string {\n    return this._getControlledValue() || this.state.inputValue || '';\n  }\n\n  public get selectionStart(): number | null {\n    return this._inputElement.current ? this._inputElement.current.selectionStart : -1;\n  }\n\n  public get selectionEnd(): number | null {\n    return this._inputElement.current ? this._inputElement.current.selectionEnd : -1;\n  }\n\n  public get inputElement(): HTMLInputElement | null {\n    return this._inputElement.current;\n  }\n\n  public componentDidUpdate(_: any, _1: any, cursor: ICursorLocation | null) {\n    const { suggestedDisplayValue, shouldSelectFullInputValueInComponentDidUpdate, preventValueSelection } = this.props;\n    let differenceIndex = 0;\n\n    if (preventValueSelection) {\n      return;\n    }\n\n    if (\n      this._autoFillEnabled &&\n      this.value &&\n      suggestedDisplayValue &&\n      _doesTextStartWith(suggestedDisplayValue, this.value)\n    ) {\n      let shouldSelectFullRange = false;\n\n      if (shouldSelectFullInputValueInComponentDidUpdate) {\n        shouldSelectFullRange = shouldSelectFullInputValueInComponentDidUpdate();\n      }\n\n      if (shouldSelectFullRange && this._inputElement.current) {\n        this._inputElement.current.setSelectionRange(0, suggestedDisplayValue.length, SELECTION_BACKWARD);\n      } else {\n        while (\n          differenceIndex < this.value.length &&\n          this.value[differenceIndex].toLocaleLowerCase() === suggestedDisplayValue[differenceIndex].toLocaleLowerCase()\n        ) {\n          differenceIndex++;\n        }\n        if (differenceIndex > 0 && this._inputElement.current) {\n          this._inputElement.current.setSelectionRange(\n            differenceIndex,\n            suggestedDisplayValue.length,\n            SELECTION_BACKWARD,\n          );\n        }\n      }\n    } else if (this._inputElement.current) {\n      if (cursor !== null && !this._autoFillEnabled && !this.state.isComposing) {\n        this._inputElement.current.setSelectionRange(cursor.start, cursor.end, cursor.dir);\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n  }\n\n  public render(): JSX.Element {\n    const nativeProps = getNativeProps<React.InputHTMLAttributes<HTMLInputElement>>(this.props, inputProperties);\n    const style = { ...this.props.style, fontFamily: 'inherit' };\n    return (\n      <input\n        autoCapitalize=\"off\"\n        autoComplete=\"off\"\n        aria-autocomplete={'both'}\n        {...nativeProps}\n        style={style}\n        ref={this._inputElement}\n        value={this._getDisplayValue()}\n        onCompositionStart={this._onCompositionStart}\n        onCompositionUpdate={this._onCompositionUpdate}\n        onCompositionEnd={this._onCompositionEnd}\n        // TODO (Fabric 8?) - switch to calling only onChange. See notes in TextField._onInputChange.\n        onChange={this._onChanged}\n        onInput={this._onInputChanged}\n        onKeyDown={this._onKeyDown}\n        onClick={this.props.onClick ? this.props.onClick : this._onClick}\n        data-lpignore={true}\n      />\n    );\n  }\n\n  public focus() {\n    this._inputElement.current && this._inputElement.current.focus();\n  }\n\n  public clear() {\n    this._autoFillEnabled = true;\n    this._updateValue('', false);\n    this._inputElement.current && this._inputElement.current.setSelectionRange(0, 0);\n  }\n\n  public getSnapshotBeforeUpdate(): ICursorLocation | null {\n    const inel = this._inputElement.current;\n\n    if (inel && inel.selectionStart !== this.value.length) {\n      return {\n        start: inel.selectionStart ?? inel.value.length,\n        end: inel.selectionEnd ?? inel.value.length,\n        dir: (inel.selectionDirection as 'forward') || 'backward' || 'none',\n      };\n    }\n    return null;\n  }\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and languages like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionStart = (ev: React.CompositionEvent<HTMLInputElement>) => {\n    this.setState({ isComposing: true });\n    this._autoFillEnabled = false;\n  };\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and languages like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionUpdate = () => {\n    if (isIE11()) {\n      this._updateValue(this._getCurrentInputValue(), true);\n    }\n  };\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and languages like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionEnd = (ev: React.CompositionEvent<HTMLInputElement>) => {\n    const inputValue = this._getCurrentInputValue();\n    this._tryEnableAutofill(inputValue, this.value, false, true);\n    this.setState({ isComposing: false });\n\n    // Due to timing, this needs to be async, otherwise no text will be selected.\n    this._async.setTimeout(() => {\n      // it's technically possible that the value of isComposing is reset during this timeout,\n      // so explicitly trigger this with composing=true here, since it is supposed to be the\n      // update for composition end\n      this._updateValue(this._getCurrentInputValue(), false);\n    }, 0);\n  };\n\n  private _onClick = () => {\n    if (this.value && this.value !== '' && this._autoFillEnabled) {\n      this._autoFillEnabled = false;\n    }\n  };\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLInputElement>) => {\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(ev);\n    }\n\n    // If the event is actively being composed, then don't alert autofill.\n    // Right now typing does not have isComposing, once that has been fixed any should be removed.\n\n    if (!(ev.nativeEvent as any).isComposing) {\n      // eslint-disable-next-line deprecation/deprecation\n      switch (ev.which) {\n        case KeyCodes.backspace:\n          this._autoFillEnabled = false;\n          break;\n        case KeyCodes.left:\n        case KeyCodes.right:\n          if (this._autoFillEnabled) {\n            this.setState({ inputValue: this.props.suggestedDisplayValue || '' });\n            this._autoFillEnabled = false;\n          }\n          break;\n        default:\n          if (!this._autoFillEnabled) {\n            // eslint-disable-next-line deprecation/deprecation\n            if (this.props.enableAutofillOnKeyPress!.indexOf(ev.which) !== -1) {\n              this._autoFillEnabled = true;\n            }\n          }\n          break;\n      }\n    }\n  };\n\n  private _onInputChanged = (ev: React.FormEvent<HTMLElement>) => {\n    const value: string = this._getCurrentInputValue(ev);\n\n    if (!this.state.isComposing) {\n      this._tryEnableAutofill(value, this.value, (ev.nativeEvent as any).isComposing);\n    }\n\n    // If it is not IE11 and currently composing, update the value\n    if (!(isIE11() && this.state.isComposing)) {\n      const nativeEventComposing = (ev.nativeEvent as any).isComposing;\n      const isComposing = nativeEventComposing === undefined ? this.state.isComposing : nativeEventComposing;\n      this._updateValue(value, isComposing);\n    }\n  };\n\n  private _onChanged = (): void => {\n    // Swallow this event, we don't care about it\n    // We must provide it because React PropTypes marks it as required, but onInput serves the correct purpose\n    return;\n  };\n\n  private _getCurrentInputValue(ev?: React.FormEvent<HTMLElement>): string {\n    if (ev && ev.target && (ev.target as HTMLInputElement).value) {\n      return (ev.target as HTMLInputElement).value;\n    } else if (this.inputElement && this.inputElement.value) {\n      return this.inputElement.value;\n    } else {\n      return '';\n    }\n  }\n\n  /**\n   * Attempts to enable autofill. Whether or not autofill is enabled depends on the input value,\n   * whether or not any text is selected, and only if the new input value is longer than the old input value.\n   * Autofill should never be set to true if the value is composing. Once compositionEnd is called, then\n   * it should be completed.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent for more information on composition.\n   * @param newValue - new input value\n   * @param oldValue - old input value\n   * @param isComposing - if true then the text is actively being composed and it has not completed.\n   * @param isComposed - if the text is a composed text value.\n   */\n  private _tryEnableAutofill(newValue: string, oldValue: string, isComposing?: boolean, isComposed?: boolean): void {\n    if (\n      !isComposing &&\n      newValue &&\n      this._inputElement.current &&\n      this._inputElement.current.selectionStart === newValue.length &&\n      !this._autoFillEnabled &&\n      (newValue.length > oldValue.length || isComposed)\n    ) {\n      this._autoFillEnabled = true;\n    }\n  }\n\n  /**\n   * Updates the current input value as well as getting a new display value.\n   * @param newValue - The new value from the input\n   */\n  private _updateValue = (newValue: string, composing: boolean) => {\n    // Only proceed if the value is nonempty and is different from the old value\n    // This is to work around the fact that, in IE 11, inputs with a placeholder fire an onInput event on focus\n    if (!newValue && newValue === this.value) {\n      return;\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    const { onInputChange, onInputValueChange } = this.props;\n    if (onInputChange) {\n      newValue = onInputChange?.(newValue, composing) || '';\n    }\n\n    this.setState({ inputValue: newValue }, () => onInputValueChange?.(newValue, composing));\n  };\n\n  private _getDisplayValue(): string {\n    if (this._autoFillEnabled) {\n      return _getDisplayValue(this.value, this.props.suggestedDisplayValue);\n    }\n\n    return this.value;\n  }\n\n  private _getControlledValue(): string | undefined {\n    const { value } = this.props;\n    if (value === undefined || typeof value === 'string') {\n      return value;\n    }\n\n    // eslint-disable-next-line no-console\n    console.warn(`props.value of Autofill should be a string, but it is ${value} with type of ${typeof value}`);\n\n    return value.toString();\n  }\n}\n/**\n * Returns a string that should be used as the display value.\n * It evaluates this based on whether or not the suggested value starts with the input value\n * and whether or not autofill is enabled.\n * @param inputValue - the value that the input currently has.\n * @param suggestedDisplayValue - the possible full value\n */\nfunction _getDisplayValue(inputValue: string, suggestedDisplayValue?: string): string {\n  let displayValue = inputValue;\n  if (suggestedDisplayValue && inputValue && _doesTextStartWith(suggestedDisplayValue, displayValue)) {\n    displayValue = suggestedDisplayValue;\n  }\n  return displayValue;\n}\n\nfunction _doesTextStartWith(text: string, startWith: string): boolean {\n  if (!text || !startWith) {\n    return false;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    for (const val of [text, startWith]) {\n      if (typeof val !== 'string') {\n        throw new Error(\n          `${\n            Autofill.name\n            // eslint-disable-next-line @fluentui/max-len\n          } received non-string value \"${val}\" of type ${typeof val} from either input's value or suggestedDisplayValue`,\n        );\n      }\n    }\n  }\n\n  return text.toLocaleLowerCase().indexOf(startWith.toLocaleLowerCase()) === 0;\n}\n"]},"metadata":{},"sourceType":"module"}